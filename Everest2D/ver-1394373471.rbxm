<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" version="4" xsi:noNameSpaceSchemaLocation="http://www.roblox.com/roblox.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <Item class="StringValue" referent="RBX0">
    <Properties>
      <string name="Name">Everest2DClient</string>
      <string name="Value"></string>
    </Properties>
    <Item class="StringValue" referent="RBX0">
      <Properties>
        <string name="Name">server</string>
        <string name="Value"></string>
      </Properties>
      <Item class="StringValue" referent="RBX0">
        <Properties>
          <string name="Name">net</string>
          <string name="Value"></string>
        </Properties>
        <Item class="StringValue" referent="RBX0">
          <Properties>
            <string name="Name">packets</string>
            <string name="Value"></string>
          </Properties>
          <Item class="LocalScript" referent="RBX0">
            <Properties>
              <string name="Name">SERVER_PACKET003_MOVE.lua</string>
              <ProtectedString name="Source">--server
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do SERVER_PACKET003_MOVE = Class(&quot;SERVER_PACKET003_MOVE&quot;)

	function SERVER_PACKET003_MOVE.new(entityLevelId, xa, ya, speed, posX, posY)
		local packet = {}
		setmetatable(packet, SERVER_PACKET003_MOVE)

		packet.entityLevelId = entityLevelId
		packet.xa = xa
		packet.ya = ya
		packet.speed = speed
		packet.posX = posX
		packet.posY = posY

		return packet
	end
	
	function SERVER_PACKET003_MOVE:Data()
		return {&quot;SERVER_PACKET003_MOVE&quot;, self.entityLevelId, self.xa, self.ya, self.speed, self.posX, self.posY}
	end
	
	
	function SERVER_PACKET003_MOVE.Handle(data)
		_G.localgame.player.level:getEntityFromId(data[2]):move(data[3], data[4], data[5], data[6], data[7])
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="LocalScript" referent="RBX0">
            <Properties>
              <string name="Name">SERVER_PACKET002_SPAWN.lua</string>
              <ProtectedString name="Source">--server
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do SERVER_PACKET002_SPAWN = Class(&quot;SERVER_PACKET002_SPAWN&quot;)

	function SERVER_PACKET002_SPAWN.new(type, playerToSpawn, x, y, id)
		local packet = {}
		setmetatable(packet, SERVER_PACKET002_SPAWN)
		
		packet.type = type
		packet.playerToSpawn = playerToSpawn
		packet.x = x
		packet.y = y
		packet.id = id
		
		return packet
	end
	
	function SERVER_PACKET002_SPAWN:Data()
		return {&quot;SERVER_PACKET002_SPAWN&quot;, self.type, self.playerToSpawn.Name, self.x, self.y, self.id}
	end
	
	Import(&quot;Player&quot;)
	
	function SERVER_PACKET002_SPAWN.Handle(data)
		if data[2] == &quot;Player&quot; then
			p = Player.new(data[6], _G.localgame, _G.localgame.level, 100, data[3], data[4], data[5], nil)
		end
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="LocalScript" referent="RBX0">
            <Properties>
              <string name="Name">SERVER_PACKET004_DISCONNECT.lua</string>
              <ProtectedString name="Source">--server
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do SERVER_PACKET004_DISCONNECT = Class(&quot;SERVER_PACKET004_DISCONNECT&quot;)

	function SERVER_PACKET004_DISCONNECT.new()
		local packet = {}
		setmetatable(packet, SERVER_PACKET004_DISCONNECT)


		return packet
	end
	
	function SERVER_PACKET004_DISCONNECT:Data()
		return {&quot;SERVER_PACKET004_DISCONNECT&quot;}
	end
	
	
	function SERVER_PACKET004_DISCONNECT.Handle(data)
		_G.localgame:stop()
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="LocalScript" referent="RBX0">
            <Properties>
              <string name="Name">SERVER_PACKET001_START.lua</string>
              <ProtectedString name="Source">--server
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do SERVER_PACKET001_START = Class(&quot;SERVER_PACKET001_START&quot;)

	function SERVER_PACKET001_START.new(level, posX, posY, id)
		local packet = {}
		setmetatable(packet, SERVER_PACKET001_START)
		
		packet.level = level
		packet.posX = posX
		packet.posY = posY
		packet.id = id
		
		return packet
	end
	
	function SERVER_PACKET001_START:Data()
		return {&quot;SERVER_PACKET001_START&quot;, self.level, self.posX, self.posY, self.id}
	end
	
	Import(&quot;Level&quot;)
	Import(&quot;Player&quot;)
	Import(&quot;CLIENT_PACKET003_KEEPCONNECTION&quot;)
	
	function SERVER_PACKET001_START.Handle(data)
		coroutine.wrap(function() while wait(5) do _G.localgame.packetHandler:sendPacket(CLIENT_PACKET003_KEEPCONNECTION.new():Data()) end end)()
	
		_G.localgame.level = Level.allLevels[data[2]]
		repeat wait(1) until _G.localgame.level.ready
		_G.localgame.player = Player.new(data[5], _G.localgame, _G.localgame.level, 100, _G.localgame.localPlayer.Name, data[3], data[4], _G.localgame.inputHandler)
		
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="LocalScript" referent="RBX0">
            <Properties>
              <string name="Name">SERVER_PACKET005_DISCONNECTOTHER.lua</string>
              <ProtectedString name="Source">--server
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do SERVER_PACKET005_DISCONNECTOTHER = Class(&quot;SERVER_PACKET005_DISCONNECTOTHER&quot;)

	function SERVER_PACKET005_DISCONNECTOTHER.new(playerName)
		local packet = {}
		setmetatable(packet, SERVER_PACKET005_DISCONNECTOTHER)

		packet.playerName = playerName

		return packet
	end
	
	function SERVER_PACKET005_DISCONNECTOTHER:Data()
		return {&quot;SERVER_PACKET005_DISCONNECTOTHER&quot;, self.playerName}
	end
	
	
	Import(&quot;Player&quot;)
	
	function SERVER_PACKET005_DISCONNECTOTHER.Handle(data)
		Player.players[data[2]]:Destroy()
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="LocalScript" referent="RBX0">
            <Properties>
              <string name="Name">SERVER_PACKET006_SPAWNEFFECT.lua</string>
              <ProtectedString name="Source">--server
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do SERVER_PACKET006_SPAWNEFFECT = Class(&quot;SERVER_PACKET006_SPAWNEFFECT&quot;)

	function SERVER_PACKET006_SPAWNEFFECT.new(id, level, speed, posX, posY, type, dirVecX, dirVecY, size, color)
		local packet = {}
		setmetatable(packet, SERVER_PACKET006_SPAWNEFFECT)
		
		packet.id = id
		packet.level = level
		packet.speed = speed
		packet.posX = posX
		packet.posY = posY
		packet.type = type
		packet.dirVecX = dirVecX
		packet.dirVecY = dirVecY
		packet.size = size
		packet.color = color
		
		return packet
	end
	
	function SERVER_PACKET006_SPAWNEFFECT:Data()
		return {&quot;SERVER_PACKET006_SPAWNEFFECT&quot;, 
				self.id,
				self.level,
				self.speed,
				self.posX,
				self.posY,
				self.type,
				self.dirVecX,
				self.dirVecY,
				self.size,
				self.color}
	end
	
	Import(&quot;BasicMissile&quot;)
	Import(&quot;Level&quot;)
	function SERVER_PACKET006_SPAWNEFFECT.Handle(data)
		if data[7] == &quot;BasicMissile&quot; then
			BasicMissile.new(data[2],Level.allLevels[data[3]],data[4],data[5],data[6],data[7],Vector2.new(data[8],data[9]),data[10],data[11])
		end
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
        </Item>
        <Item class="LocalScript" referent="RBX0">
          <Properties>
            <string name="Name">ServerPacketHandler.lua</string>
            <ProtectedString name="Source">--server
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do ServerPacketHandler = Class(&quot;ServerPacketHandler&quot;)

	function ServerPacketHandler.new(server)
		local serverPacketHandler = {}
		setmetatable(serverPacketHandler, ServerPacketHandler)
		
		serverPacketHandler.server = server
		serverPacketHandler.handle = Instance.new(&quot;RemoteFunction&quot;, Workspace)
		serverPacketHandler.handle.Name = &quot;PacketHandler&quot;
		
		function serverPacketHandler.handle.OnServerInvoke(player, data)
			serverPacketHandler:receivedPacket(player, data)
		end
		
		return serverPacketHandler
	end
	
	function ServerPacketHandler:sendPacket(player, data)
		local stringData = &quot;&quot;
		for _, v in pairs(data) do stringData = stringData .. &quot; &quot; .. tostring(v) end
		--print(tick() .. &quot;: Server sending packet &quot; .. stringData .. &quot; to player &quot; .. player.Name)
		coroutine.wrap(function(player, data)
			self.handle:InvokeClient(player, data)
		end)(player, data)
		data = nil
	end
	
	Import(&quot;CLIENT_PACKET001_LOGIN&quot;)
	Import(&quot;CLIENT_PACKET002_MOVE&quot;)
	Import(&quot;CLIENT_PACKET003_KEEPCONNECTION&quot;)
	Import(&quot;CLIENT_PACKET004_SPAWNEFFECT&quot;)
	function ServerPacketHandler:receivedPacket(player, data)
		local stringData = &quot;&quot;
		for _, v in pairs(data) do stringData = stringData .. &quot; &quot; .. tostring(v) end
		--print(tick() .. &quot;: Server received packet &quot; .. stringData .. &quot; from player &quot; .. player.Name)
		getfenv()[data[1]].Handle(player, data)
		data = nil
	end
	
end</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
      </Item>
      <Item class="LocalScript" referent="RBX0">
        <Properties>
          <string name="Name">Server.lua</string>
          <ProtectedString name="Source">--Handles entity ai, player positions, chat, etc.

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do Server = Class(&quot;Server&quot;)

	Import(&quot;ServerPacketHandler&quot;)
	function Server.new()
		print(&quot;!!!SERVER INITIALISING!!!&quot;)
		local server = {}
		setmetatable(server, Server)

		_G.localserver = server
		server.packetHandler = ServerPacketHandler.new(server)
		server.players = {}
		server.playersLastConnect = {}

		return server
	end

end
</ProtectedString>
          <Content name="LinkedSource">null</Content>
          <bool name="Disabled">false</bool>
        </Properties>
      </Item>
    </Item>
    <Item class="StringValue" referent="RBX0">
      <Properties>
        <string name="Name">game</string>
        <string name="Value"></string>
      </Properties>
      <Item class="LocalScript" referent="RBX0">
        <Properties>
          <string name="Name">InputHandler.lua</string>
          <ProtectedString name="Source">--Custom input handler for convenience

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do InputHandler = Class(&quot;InputHandler&quot;)
	
	function InputHandler.new(game)
		local inputHandler = {}
		setmetatable(inputHandler, InputHandler)		
		
		inputHandler.keys = {}
		inputHandler.mouse = game.localPlayer:GetMouse()		
		
		--Allows to easily see which keys are being held down
		inputHandler.mouse.KeyDown:connect(function(key) inputHandler:keyDown(key) end)		
		inputHandler.mouse.KeyUp:connect(function(key) inputHandler:keyUp(key) end)		
		inputHandler.mouse.Button1Down:connect(function() inputHandler:keyDown(&quot;Button1&quot;) end)
		inputHandler.mouse.Button1Up:connect(function() inputHandler:keyUp(&quot;Button1&quot;) end)	
		
		return inputHandler
	end
	
	function InputHandler:keyDown(key)
		self.keys[key] = true
	end
	
	function InputHandler:keyUp(key)
		self.keys[key] = false		
	end
end</ProtectedString>
          <Content name="LinkedSource">null</Content>
          <bool name="Disabled">false</bool>
        </Properties>
      </Item>
      <Item class="StringValue" referent="RBX0">
        <Properties>
          <string name="Name">util</string>
          <string name="Value"></string>
        </Properties>
        <Item class="LocalScript" referent="RBX0">
          <Properties>
            <string name="Name">Import.lua</string>
            <ProtectedString name="Source">--Allows you to import a class (this was made before modulescripts)

function _G.Import(toImport)
	print(&quot;IMPORTING &quot; .. toImport)
	wait()
	if not _G[toImport] then
		repeat wait(0.1) print(&quot;STILL IMPORTING &quot; .. toImport) 
		until _G[toImport]
	end
	getfenv(2)[toImport] = _G[toImport]
end
</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="RBX0">
          <Properties>
            <string name="Name">LocalPlayer.lua</string>
            <ProtectedString name="Source">--client

--Just a reference for the localplayer incase it gets lost

_G.LocalPlayer = game.Players.LocalPlayer</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="RBX0">
          <Properties>
            <string name="Name">Class.lua</string>
            <ProtectedString name="Source">
function _G.Class(className)
	local class = {}
	_G[className] = class
	class.__Index = class
	
	return class
end</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="RBX0">
          <Properties>
            <string name="Name">Extends.lua</string>
            <ProtectedString name="Source">--client

--allows a class to extend another

function _G.Extends(className, toExtend)
	local extendee = {}
	setmetatable(extendee, toExtend)
	
	_G[className] = extendee
	extendee.__Index = extendee
	
	return extendee
end</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
      </Item>
      <Item class="StringValue" referent="RBX0">
        <Properties>
          <string name="Name">graphics</string>
          <string name="Value"></string>
        </Properties>
        <Item class="LocalScript" referent="RBX0">
          <Properties>
            <string name="Name">Screen.lua</string>
            <ProtectedString name="Source">--This is essentially the camera

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(Class)

do Screen = Class(&quot;Screen&quot;)

	Import(&quot;Hud&quot;)

	function Screen.new(game, sizeX, sizeY)
		local screen = {}
		setmetatable(screen, Screen)

		screen.ClippingMask = Instance.new(&quot;Frame&quot;, game.canvas)
		screen.ClippingMask.Size = UDim2.new(1,0,1,0)
		screen.ClippingMask.BackgroundColor3 = Color3.new(0,0,0)
		screen.ClippingMask.BackgroundTransparency = 0
		screen.ClippingMask.Name = &quot;Clipping Mask&quot;

		screen.frame = Instance.new(&quot;Frame&quot;, game.canvas)
		screen.frame.Size = UDim2.new(1,0,1,0)
		screen.frame.ZIndex = 2
		screen.frame.BackgroundTransparency = 1
		screen.frame.Name = &quot;Screen&quot;
		screen.testFrame = Instance.new(&quot;Frame&quot;, screen.frame)
		screen.testFrame.Size = UDim2.new(0,10,0,10)
		screen.testFrame.ZIndex = 6
		screen.testFrame.BackgroundTransparency = 0
		screen.testFrame.Name = &quot;testFrame&quot;
		
		screen.posX = 0
		screen.posY = 0
		
		screen.game = game
		screen.sizeX = sizeX
		screen.sizeY = sizeY
		screen.rendered = {}
		
		screen.hud = Hud.new(screen)
		
		
		return screen
	end

	Import(&quot;Tile&quot;)

	--Warning dense code ahead!
	function Screen:render(deltaTime, posX, posY)

		--Waits for the level to load itself
		while not self.game.level.ready and not #Tile.Tiles &gt; 0 do wait() end
		
		--Stops the screen from moving over the edge of the map
		posX = math.min(self.game.level.width - 1 - (self.sizeX), posX)
		posY = math.min(self.game.level.height - 1 - (self.sizeY), posY)
		posX = math.max(1, posX)
		posY = math.max(1, posY)
		
		self.posX = posX
		self.posY = posY
		
		local posVec = Vector2.new(-posX * 32, -posY * 32)
		local currentPosVec = Vector2.new(self.frame.AbsolutePosition.X, self.frame.AbsolutePosition.Y)
		
		local newPos = currentPosVec:lerp(posVec, 8 * deltaTime)
		
		self.frame.Position = UDim2.new(0, newPos.X, 0, newPos.Y)

		local used = {}
		
		--Rounded so it matched up with the levels integer positions
		posX = math.floor(posX)
		posY = math.floor(posY)

		--Loops the size of the screen plus 1/4 over the edges
		for x = math.floor(-self.sizeX / 4), math.floor(self.sizeX + self.sizeY / 4) do
			for y = math.floor(-self.sizeY / 4), math.floor(self.sizeY + self.sizeY / 4) do
				local posXX = math.min(self.game.level.width, posX + x)
				local posYY = math.min(self.game.level.height, posY + y)
				posXX = math.max(1, posXX)
				posYY = math.max(1, posYY)

				self.rendered[posXX] = self.rendered[posXX] or {}
				used[posXX] = used[posXX] or {}
				used[posXX][posYY] = true
				
				--Checks if this tile has already been rendered, if not it renders it
				if not self.rendered[posXX][posYY] then
					if self.game.level.tiles[posXX] and self.game.level.tiles[posXX][posYY] then
						self.rendered[posXX][posYY] = Tile.Tiles[self.game.level.tiles[posXX][posYY]]:render(self, posXX, posYY)
					end
				end
			end
		end
		
		--Checks the rendered tiles to see if they still need to be rendered
		--I.E removes tiles that are not on the screen
		for x, ytab in pairs(self.rendered) do
			for y, tile in pairs(ytab) do
				if not used[x] then
					for y, tile in pairs(ytab) do
						tile:Destroy()
						self.rendered[x][y] = nil
					end
					self.rendered[x] = nil
					used[x] = nil
					break
				elseif not used[x][y] then
					tile:Destroy()
					self.rendered[x][y] = nil
					used[x][y] = nil
				end
			end
		end

	end
end</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="RBX0">
          <Properties>
            <string name="Name">Hud.lua</string>
            <ProtectedString name="Source">--Heads up display

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do Hud = Class(&quot;Hud&quot;)
	
	function Hud.new(screen)
		local hud = {}
		setmetatable(hud, Hud)
		
		hud.screen = screen
		hud.frame = Instance.new(&quot;Frame&quot;, screen.frame.Parent)
		hud.frame.Size = UDim2.new(1,0,1,0)
		hud.frame.ZIndex = 9
		hud.frame.BackgroundTransparency = 1
		hud.frame.Name = &quot;Hud&quot;
		
		hud.playerInfo = Instance.new(&quot;ImageLabel&quot;, hud.frame)
		hud.playerInfo.Size = UDim2.new(0, 300, 0, 100)
		hud.playerInfo.BackgroundTransparency = 1
		hud.playerInfo.BackgroundColor3 = Color3.new(0,0,0)
		hud.playerInfo.Name = &quot;PlayerInfo&quot;
		hud.playerInfo.Image = &quot;http://www.roblox.com/asset/?id=135283499&quot;
		hud.playerInfo.ZIndex = 9
		
		hud.playerName = Instance.new(&quot;TextLabel&quot;, hud.playerInfo)
		hud.playerName.Size = UDim2.new(0,120,0,20)
		hud.playerName.Position = UDim2.new(0,90,0,24)
		hud.playerName.BackgroundTransparency = 1
		hud.playerName.Text = screen.game.localPlayer.Name
		hud.playerName.TextXAlignment = &quot;Left&quot;
		hud.playerName.TextScaled = true
		hud.playerName.FontSize = &quot;Size24&quot;
		hud.playerName.Font = &quot;ArialBold&quot;
		hud.playerName.TextColor3 = Color3.new(1,1,1)
		hud.playerName.TextStrokeTransparency = 0
		hud.playerName.Name = &quot;PlayerName&quot;
		hud.playerName.ZIndex = 9
		
		hud.playerHealth = Instance.new(&quot;TextLabel&quot;, hud.playerInfo)
		
		
		
		return hud
	end
	
end</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="RBX0">
          <Properties>
            <string name="Name">SpriteSheet.lua</string>
            <ProtectedString name="Source">--Simplified images

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do SpriteSheet = Class(&quot;SpriteSheet&quot;)
	
	function SpriteSheet.new(name, urlId, spriteSizeX, spriteSizeY)
		local spriteSheet = {}
		setmetatable(spriteSheet, SpriteSheet)
	
		spriteSheet.name = name
		spriteSheet.url = &quot;http://www.roblox.com/asset/?id=&quot; .. urlId
		spriteSheet.spriteSizeX = spriteSizeX
		spriteSheet.spriteSizeY = spriteSizeY
		spriteSheet.vector2Size = Vector2.new(spriteSizeX, spriteSizeY)
	
		return spriteSheet
	end
	
	SpriteSheet.BasicSpriteSheet = SpriteSheet.new(&quot;basic&quot;, 134517395, 32, 32)		
	
end</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
      </Item>
      <Item class="StringValue" referent="RBX0">
        <Properties>
          <string name="Name">net</string>
          <string name="Value"></string>
        </Properties>
        <Item class="StringValue" referent="RBX0">
          <Properties>
            <string name="Name">packets</string>
            <string name="Value"></string>
          </Properties>
          <Item class="LocalScript" referent="RBX0">
            <Properties>
              <string name="Name">CLIENT_PACKET001_LOGIN.lua</string>
              <ProtectedString name="Source">--client

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do CLIENT_PACKET001_LOGIN = Class(&quot;CLIENT_PACKET001_LOGIN&quot;)

	function CLIENT_PACKET001_LOGIN.new()
		local packet = {}
		setmetatable(packet, CLIENT_PACKET001_LOGIN)

		return packet
	end

	function CLIENT_PACKET001_LOGIN:Data()
		return {&quot;CLIENT_PACKET001_LOGIN&quot;}
	end

	Import(&quot;Player&quot;)
	Import(&quot;Level&quot;)
	Import(&quot;SERVER_PACKET001_START&quot;)
	Import(&quot;SERVER_PACKET002_SPAWN&quot;)
	Import(&quot;SERVER_PACKET004_DISCONNECT&quot;)
	Import(&quot;SERVER_PACKET005_DISCONNECTOTHER&quot;)

	function CLIENT_PACKET001_LOGIN.Handle(player, data)

		_G.localserver.players[player] = {lastInteracted = tick(), player = Player.new(nil, _G.localgame, Level.allLevels[&quot;TestLevel&quot;], 100, player.Name, 5, 5, nil)}
		_G.localserver.packetHandler:sendPacket(player, SERVER_PACKET001_START.new(&quot;TestLevel&quot;, 5, 5, _G.localserver.players[player].player.levelId):Data())
		
		for playerToSpawn, playerInTable in pairs(_G.localserver.players) do
			if playerToSpawn ~= player then
				_G.localserver.packetHandler:sendPacket(player, 
					SERVER_PACKET002_SPAWN.new(&quot;Player&quot;, playerToSpawn, playerInTable.player.posX, playerInTable.player.posY, _G.localserver.players[playerToSpawn].player.levelId):Data())
			end
		end

		for playerToSend, _ in pairs(_G.localserver.players) do
			if playerToSend ~= player then
				_G.localserver.packetHandler:sendPacket(playerToSend, SERVER_PACKET002_SPAWN.new(&quot;Player&quot;, player, 5, 5, _G.localserver.players[player].player.levelId):Data())
			end
		end
		
		
		
		coroutine.wrap(function() 
			repeat 
				wait(10) 
			until _G.localserver.players[player].lastInteracted + 10 &lt; tick() 
			print(&quot;Disconnecting player &quot; .. player.Name .. &quot; due to lost connection.&quot;)
			_G.localserver.packetHandler:sendPacket(player, SERVER_PACKET004_DISCONNECT.new():Data())
			for playerTo, _ in pairs(_G.localserver.players) do
				if playerTo ~= player then
					_G.localserver.packetHandler:sendPacket(playerTo, SERVER_PACKET005_DISCONNECTOTHER.new(player.Name):Data())
				end
			end
			_G.localserver.players[player] = nil
		end)()
		
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="LocalScript" referent="RBX0">
            <Properties>
              <string name="Name">CLIENT_PACKET004_SPAWNEFFECT.lua</string>
              <ProtectedString name="Source">--client

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do CLIENT_PACKET004_SPAWNEFFECT = Class(&quot;CLIENT_PACKET004_SPAWNEFFECT&quot;)

	function CLIENT_PACKET004_SPAWNEFFECT.new(id, level, speed, posX, posY, type, dirVec, size, color)
		local packet = {}
		setmetatable(packet, CLIENT_PACKET004_SPAWNEFFECT)
		
		packet.id = id
		packet.level = level
		packet.speed = speed
		packet.posX = posX
		packet.posY = posY
		packet.type = type
		packet.dirVec = dirVec
		packet.size = size
		packet.color = color
		
		return packet
	end

	function CLIENT_PACKET004_SPAWNEFFECT:Data()
		return {&quot;CLIENT_PACKET004_SPAWNEFFECT&quot;, 
				self.id,
				self.level.name,
				self.speed,
				self.posX,
				self.posY,
				self.type,
				self.dirVec.X,
				self.dirVec.Y,
				self.size,
				self.color}
	end

	Import(&quot;SERVER_PACKET006_SPAWNEFFECT&quot;)

	function CLIENT_PACKET004_SPAWNEFFECT.Handle(player, data)
		for playerToSend, _ in pairs(_G.localserver.players) do
			if playerToSend ~= player then
				_G.localserver.packetHandler:sendPacket(playerToSend, 
					SERVER_PACKET006_SPAWNEFFECT.new(data[2],data[3],data[4],data[5],data[6],data[7],data[8],data[9],data[10],data[11]):Data())
			end
		end
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="LocalScript" referent="RBX0">
            <Properties>
              <string name="Name">CLIENT_PACKET002_MOVE.lua</string>
              <ProtectedString name="Source">--client

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do CLIENT_PACKET002_MOVE = Class(&quot;CLIENT_PACKET002_MOVE&quot;)

	function CLIENT_PACKET002_MOVE.new(id, xa, ya, speed, posX, posY)
		local packet = {}
		setmetatable(packet, CLIENT_PACKET002_MOVE)

		packet.id = id
		packet.xa = xa
		packet.ya = ya
		packet.speed = speed
		packet.posX = posX
		packet.posY = posY

		return packet
	end

	function CLIENT_PACKET002_MOVE:Data()
		return {&quot;CLIENT_PACKET002_MOVE&quot;, self.id, self.xa, self.ya, self.speed, self.posX, self.posY}
	end

	Import(&quot;SERVER_PACKET003_MOVE&quot;)

	function CLIENT_PACKET002_MOVE.Handle(player, data)
		for playerTo, _ in pairs(_G.localserver.players) do
			if playerTo ~= player then
				_G.localserver.packetHandler:sendPacket(playerTo, SERVER_PACKET003_MOVE.new(data[2], data[3], data[4], data[5], _G.localserver.players[player].player.posX, _G.localserver.players[player].player.posY):Data())
			end
		end

		_G.localserver.players[player].player.posX = _G.localserver.players[player].player.posX + (data[3] * data[5])
		_G.localserver.players[player].player.posY = _G.localserver.players[player].player.posY + (data[4] * data[5])
		_G.localserver.players[player].lastInteracted = tick()

		if data[6] ~= _G.localserver.players[player].player.posX or data[7] ~= _G.localserver.players[player].player.posY then
			_G.localserver.packetHandler:sendPacket(player, SERVER_PACKET003_MOVE.new(data[2], data[3], 0, 0, _G.localserver.players[player].player.posX, _G.localserver.players[player].player.posY):Data())
		end
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="LocalScript" referent="RBX0">
            <Properties>
              <string name="Name">CLIENT_PACKET003_KEEPCONNECTION.lua</string>
              <ProtectedString name="Source">--client

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do CLIENT_PACKET003_KEEPCONNECTION = Class(&quot;CLIENT_PACKET003_KEEPCONNECTION&quot;)

	function CLIENT_PACKET003_KEEPCONNECTION.new()
		local packet = {}
		setmetatable(packet, CLIENT_PACKET003_KEEPCONNECTION)

		return packet
	end

	function CLIENT_PACKET003_KEEPCONNECTION:Data()
		return {&quot;CLIENT_PACKET003_KEEPCONNECTION&quot;}
	end

	function CLIENT_PACKET003_KEEPCONNECTION.Handle(player, data)
		_G.localserver.players[player].lastInteracted = tick()
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
        </Item>
        <Item class="LocalScript" referent="RBX0">
          <Properties>
            <string name="Name">ClientPacketHandler.lua</string>
            <ProtectedString name="Source">--client
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do ClientPacketHandler = Class(&quot;ClientPacketHandler&quot;)

	function ClientPacketHandler.new(game)
		local clientPacketHandler = {}
		setmetatable(clientPacketHandler, ClientPacketHandler)
		
		clientPacketHandler.game = game
		clientPacketHandler.handle = Workspace.PacketHandler
		
		function clientPacketHandler.handle.OnClientInvoke(data)
			clientPacketHandler:receivedPacket(data)
		end
		
		return clientPacketHandler
	end
	
	function ClientPacketHandler:sendPacket(data)
		local stringData = &quot;&quot;
		for _, v in pairs(data) do stringData = stringData .. &quot; &quot; .. tostring(v) end
		--print(tick() .. &quot;: Client sending packet &quot; .. stringData)
		coroutine.wrap(function(data)
			self.handle:InvokeServer(data)
		end)(data)
		data = nil
	end
	
	Import(&quot;SERVER_PACKET001_START&quot;)
	Import(&quot;SERVER_PACKET002_SPAWN&quot;)
	Import(&quot;SERVER_PACKET003_MOVE&quot;)
	Import(&quot;SERVER_PACKET004_DISCONNECT&quot;)
	Import(&quot;SERVER_PACKET005_DISCONNECTOTHER&quot;)
	Import(&quot;SERVER_PACKET006_SPAWNEFFECT&quot;)
	function ClientPacketHandler:receivedPacket(data)
		local stringData = &quot;&quot;
		for _, v in pairs(data) do stringData = stringData .. &quot; &quot; .. tostring(v) end
		--print(tick() .. &quot;: Client received packet &quot; .. stringData)
		getfenv()[data[1]].Handle(data)
		data = nil
	end
	
end</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
      </Item>
      <Item class="StringValue" referent="RBX0">
        <Properties>
          <string name="Name">entities</string>
          <string name="Value"></string>
        </Properties>
        <Item class="StringValue" referent="RBX0">
          <Properties>
            <string name="Name">mobs</string>
            <string name="Value"></string>
          </Properties>
          <Item class="LocalScript" referent="RBX0">
            <Properties>
              <string name="Name">Player.lua</string>
              <ProtectedString name="Source">--Player class, all players use this class

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Extends&quot;)
Import(&quot;Mob&quot;)

do Player = Extends(&quot;Player&quot;, Mob)
		
	Import(&quot;SpriteSheet&quot;)
	
	Player.players = {}
	
	function Player.new(id, game, level, health, name, posX, posY, input)
		local player = Mob.new(id, game, level, health, name, 0.3		, posX, posY, &quot;PLAYER&quot;)
		setmetatable(player, Player)
		
		
		if name == game.localPlayer.Name then
			player.frame.ZIndex = 6
		end
		
		player.input = input	
		player.scale = 2
		player.game = game
		player.frame.Name = name
		player.frame.Image = SpriteSheet.BasicSpriteSheet.url
		player.frame.ImageRectSize = Vector2.new(32, 32)
		player.frame.ImageRectOffset = Vector2.new(0, 128)
		
		Player.players[name] = player
		
		return player
	end
	
	Import(&quot;CLIENT_PACKET002_MOVE&quot;)
	Import(&quot;CLIENT_PACKET004_SPAWNEFFECT&quot;)
	Import(&quot;BasicMissile&quot;)
	
	function Player:tick()
		local xa = 0
		local ya = 0
		
		if self.input then
			if self.input.keys[&quot;w&quot;] then
				ya = ya - 1
			end
			if self.input.keys[&quot;s&quot;] then
				ya = ya + 1
			end
			if self.input.keys[&quot;a&quot;] then
				xa = xa - 1
			end
			if self.input.keys[&quot;d&quot;] then
				xa = xa + 1
			end
			if self.input.keys[&quot;Button1&quot;] then
				local mousePos = Vector2.new((self.input.mouse.X + _G.localgame.screen.posX * 32)/32, (self.input.mouse.Y + _G.localgame.screen.posY * 32)/32)
				local dirVec = (mousePos - Vector2.new(self.posX, self.posY)).unit
				local missile = BasicMissile.new(#self.level.entities + 1, self.level, 3, self.posX, self.posY, &quot;BasicMissile&quot;, dirVec, UDim2.new(0, 10, 0, 10), Color3.new(0,191/255,1))
				self.game.packetHandler:sendPacket(CLIENT_PACKET004_SPAWNEFFECT.new(#self.level.entities + 1, self.level, 3, self.posX, self.posY, &quot;BasicMissile&quot;, dirVec, UDim2.new(0, 10, 0, 10), Color3.new(255/255,50/255,50/255)):Data())
			end
		end
		
		if xa ~= 0 or ya ~= 0 then
			xa, ya = self:move(xa, ya)
			
			xa = xa or 0
			ya = ya or 0
			
			self.isMoving = true
			self.game.packetHandler:sendPacket(CLIENT_PACKET002_MOVE.new(self.levelId, xa, ya, self.speed, self.posX, self.posY):Data())
		else
			self.isMoving = false
		end
		
	end	
	
	function Player:render(deltaTime)
		local animCycle = 2 - math.floor((self.numSteps * (self.speed * 5)) % 30 / 10)	
		
		
		local posVec = Vector2.new(self.posX * 32, self.posY * 32)
		local currentPosVec = Vector2.new(self.frame.AbsolutePosition.X, self.frame.AbsolutePosition.Y)
		
		local newPos = currentPosVec:lerp(posVec, 8 * deltaTime)
		
		self.frame.Position = UDim2.new(0, posVec.X, 0, posVec.Y)
		
		self.frame:TweenSize(UDim2.new(0, 32 * self.scale, 0, 32 * self.scale), &quot;Out&quot;, &quot;Linear&quot;, 0.2, true)
		
		if self.movingDir == &quot;NORTH&quot; then
			self.frame.ImageRectOffset = Vector2.new(32 * animCycle, 225)
			self.frame.ImageRectSize = Vector2.new(31, 31)
		end
		if self.movingDir == &quot;EAST&quot; then
			self.frame.ImageRectOffset = Vector2.new(32 * animCycle, 193)
			self.frame.ImageRectSize = Vector2.new(31, 31)			
		end
		if self.movingDir == &quot;SOUTH&quot; then
			self.frame.ImageRectOffset = Vector2.new(32 * animCycle, 129)
			self.frame.ImageRectSize = Vector2.new(31, 31)
		end
		if self.movingDir == &quot;WEST&quot; then
			self.frame.ImageRectOffset = Vector2.new(32 * animCycle, 161)
			self.frame.ImageRectSize = Vector2.new(31, 31)			
		end
	end
	
	function Player:hasCollided(xa, ya)
		return self:isSolidTile(self.posX, self.posY, xa, ya)	
	end
	
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="LocalScript" referent="RBX0">
            <Properties>
              <string name="Name">Mob.lua</string>
              <ProtectedString name="Source">--Base mob class, mobs should extend this class

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Extends&quot;)
Import(&quot;Entity&quot;)

do Mob = Extends(&quot;Mob&quot;, Entity)

	function Mob.new(id, game, level, hp, name, speed, posX, posY, type)
		local mob = Entity.new(id, level, posX, posY)
		setmetatable(mob, Mob)

		mob.name = name
		mob.hp = hp
		mob.speed = speed
		mob.type = type
		mob.numSteps = 0
		mob.isMoving = false
		mob.movingDir = &quot;SOUTH&quot;
		mob.scale = 1
		mob.frame = Instance.new(&quot;ImageLabel&quot;, game.screen.frame)
		mob.frame.BorderSizePixel = 0
		mob.frame.BackgroundTransparency = 1
		mob.frame.ZIndex = 5

		mob.nameToolTip = Instance.new(&quot;TextLabel&quot;, mob.frame)
		mob.nameToolTip.Text = name .. &quot;:&quot; .. mob.levelId
		mob.nameToolTip.Size = UDim2.new(1,0,0.3,0)
		mob.nameToolTip.Position = UDim2.new(0,0,-0.5,0)
		mob.nameToolTip.BackgroundTransparency = 1
		mob.nameToolTip.BorderSizePixel = 0
		mob.nameToolTip.FontSize = &quot;Size18&quot;
		mob.nameToolTip.ZIndex = 8

		return mob
	end

	--xa is the distance across x it is moving
	--xy is the same for the y axis
	--type is the speed at which they move
	--truePosX is for synchronisation with the server (forces the entity to that position)
	--truePosY is the same but for the y axis
	function Mob:move(xa, ya, type, truePosX, truePosY)
	
		self.posX = truePosX or self.posX
		self.posY = truePosY or self.posY
	
		if xa ~= 0 and ya ~= 0 then
			xa = xa * math.cos(45)
			ya = ya * math.cos(45)
		end

		self.numSteps = self.numSteps + 1

		if not self:hasCollided(xa, ya) then

			if ya &lt; 0 then self.movingDir = &quot;NORTH&quot; end
			if ya &gt; 0 then self.movingDir = &quot;SOUTH&quot; end
			if xa &lt; 0 then self.movingDir = &quot;WEST&quot; end
			if xa &gt; 0 then self.movingDir = &quot;EAST&quot; end

			self.posX = math.min(self.posX + (xa * self.speed), self.level.width)
			self.posX = math.max(self.posX, 0)
			self.posY = math.min(self.posY + (ya * self.speed), self.level.height)
			self.posY = math.max(self.posY, 0)

			self.currentTile = self.level.tiles[math.floor(self.posX + 0.5)][math.floor(self.posY + 0.5)]

			return xa, ya
		end

	end

	--Should be custom for every mob due to differing behavour
	function Mob:hasCollided()
		error(&quot;Attempted to call hasCollided on native mob class.&quot;)
	end

	Import(&quot;Tile&quot;)

	--Find if the mob moving from x,y via xa ya will collide with a tile
	--Factors in the scale of the mob
	function Mob:isSolidTile(x, y, xa, ya)

		local x = math.max(0, math.floor(x + xa))
		local x = math.min(self.level.width, x)
		local y = math.max(0, math.floor(y + ya))
		local y = math.min(self.level.height, y)

		local solid = false
		if x &gt;= self.level.width - 1 or x &lt;= 0 or y &gt;= self.level.height - 1 or y &lt;= 0 then return true end
		for xi = 0, math.ceil(self.scale) do
			for yi = 0, math.ceil(self.scale) do
				local nextTile = Tile.Tiles[self.level.tiles[x + xi][y + yi]]
				if not nextTile.isWalkable then solid = true end
			end
		end
		local nextTile = Tile.Tiles[self.level.tiles[x][y]]

		return solid

	end

end
</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
        </Item>
        <Item class="LocalScript" referent="RBX0">
          <Properties>
            <string name="Name">Entity.lua</string>
            <ProtectedString name="Source">--Base entity class, should not really be used for anything other than setting up other classes

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do Entity = Class(&quot;Entity&quot;)
	
	function Entity.new(id, level, posX, posY)
		entity = {}
		setmetatable(entity, Entity)
		
		entity.level = level
		if id then
			level.entities[id] = entity
			entity.levelId = id
		else
			table.insert(level.entities, entity)
			entity.levelId = #level.entities
		end
		entity.posX = posX
		entity.posY = posY
		
		return entity
	end
	
	function Entity:tick()
		
	end
	
	function Entity:render()
		--Entities should have their own render function due to graphical diversity
		error(&quot;Attempted to render base entity&quot;)
	end	
	
	function Entity:Destroy()
		self.level.entities[self.levelId] = nil
		if self.frame then
			self.frame:Destroy()
		end
		self = nil
	end
	
end</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
        <Item class="StringValue" referent="RBX0">
          <Properties>
            <string name="Name">effects</string>
            <string name="Value"></string>
          </Properties>
          <Item class="LocalScript" referent="RBX0">
            <Properties>
              <string name="Name">BasicMissile.lua</string>
              <ProtectedString name="Source">--client
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Extends&quot;)
Import(&quot;Entity&quot;)

do BasicMissile = Extends(Entity)
	_G.BasicMissile = BasicMissile
	BasicMissile.__index = BasicMissile

	function BasicMissile.new(id, level, speed, posX, posY, type, dirVec, size, color)
		local basicMissile = Entity.new(id, level, posX, posY)
		setmetatable(basicMissile, BasicMissile)

		basicMissile.speed = speed
		basicMissile.type = type
		basicMissile.movingDir = movingDir
		basicMissile.size = size
		basicMissile.color = color
		basicMissile.frame = Instance.new(&quot;ImageLabel&quot;, _G.localgame.screen.frame)
		basicMissile.frame.Name = &quot;testBasicMissile&quot;
		basicMissile.frame.Size = size
		basicMissile.frame.BorderSizePixel = 0
		basicMissile.frame.BackgroundTransparency = 0
		basicMissile.frame.ZIndex = 5
		basicMissile.frame.Position = UDim2.new(0, posX * 32, 0, posY * 32)
		basicMissile.frame.BackgroundColor3 = color
		basicMissile.endPos = basicMissile.level:rayCast(Vector2.new(posX, posY), dirVec)
		local timeToTake = (Vector2.new(posX, posY) - basicMissile.endPos).magnitude^.5 / speed
		basicMissile.frame:TweenPosition(UDim2.new(0, basicMissile.endPos.X * 32, 0, basicMissile.endPos.Y * 32), &quot;Out&quot;, &quot;Linear&quot;, timeToTake, true)
		coroutine.wrap(function() 
			while basicMissile do 
				wait()
				local particle = Instance.new(&quot;ImageLabel&quot;, _G.localgame.screen.frame)
				local particleSize = math.random(1,5)
				particle.Size = UDim2.new(0,particleSize,0,particleSize)
				particle.BackgroundColor3 = color
				particle.BorderSizePixel = 0
				particle.BackgroundTransparency = math.random(0,100) / 100
				particle.ZIndex = 5
				particle.Position = basicMissile.frame.Position + UDim2.new(0, math.random(0,10), 0, math.random(0,10))
				particle:TweenPosition(particle.Position + UDim2.new(0, math.random(-20,20), 0, math.random(-20,20)), &quot;Out&quot;, &quot;Linear&quot;, 2, true)
				coroutine.wrap(function() while particle.BackgroundTransparency &lt; 1 do wait() particle.BackgroundTransparency = particle.BackgroundTransparency + 0.02 end end)()
				game:GetService(&quot;Debris&quot;):AddItem(particle, 6)	
			end
		end)()
		coroutine.wrap(function() wait(timeToTake) basicMissile.frame:Destroy() basicMissile.level.entities[basicMissile.levelId] = nil basicMissile = nil end)()
		return basicMissile
	end
	
	function BasicMissile:render()
	
	end
end
</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="LocalScript" referent="RBX0">
        <Properties>
          <string name="Name">Game.lua</string>
          <ProtectedString name="Source">--The game class coordinates all of the games calls and functions


--Allows access to the datamodel
if script.Parent.ClassName == &quot;LocalScript&quot; then game.Players.LocalPlayer.PlayerGui.Everest2D.Parent = nil end

_G.rbxGame = game
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

--Defines the game class
do Game = Class(&quot;Game&quot;)

	function Game.new()
		local game = {}
		setmetatable(game, Game)

		Import(&quot;Screen&quot;)
		
		if not _G.isServer then 
			local tempScreenSize = LocalPlayer.PlayerGui.ScreenGui.AbsoluteSize
		
			LocalPlayer.PlayerGui.ScreenGui:Destroy()
			
			game.canvasPart = Instance.new(&quot;Part&quot;, Workspace.CurrentCamera)
			game.canvasPart.Anchored = true
			game.canvasPart.FormFactor = &quot;Custom&quot;
			game.canvasPart.Size = Vector3.new(3*math.tan(math.rad(35)) * 2 * (tempScreenSize.X/tempScreenSize.Y) , 3*math.tan(math.rad(35)) * 2, 0)
			
			Workspace.CurrentCamera.CameraType = &quot;Scriptable&quot;
			Workspace.CurrentCamera.CameraSubject = game.canvasPart
			Workspace.CurrentCamera.CoordinateFrame = CFrame.new(game.canvasPart.Position + game.canvasPart.CFrame.lookVector*3.1, game.canvasPart.Position)
			Workspace.CurrentCamera.Focus = game.canvasPart.CFrame
			
			game.canvas = Instance.new(&quot;SurfaceGui&quot;, game.canvasPart)
			game.canvas.CanvasSize = tempScreenSize
			game.canvas.Adornee = game.canvasPart
			
			Import(&quot;InputHandler&quot;)
			Import(&quot;ClientPacketHandler&quot;)
			
			game.localPlayer = LocalPlayer
			game.inputHandler = InputHandler.new(game)
			game.packetHandler = ClientPacketHandler.new()
			
		else
			game.localPlayer = {Name = &quot;Server&quot;}
			game.canvas = Instance.new(&quot;ScreenGui&quot;, game.ServerStorage)
			
		end
		game.canvas.Name = &quot;Everest2DGame&quot;

		game.screen = Screen.new(game, math.ceil(game.canvas.AbsoluteSize.X / 32), math.ceil(game.canvas.AbsoluteSize.Y / 32))
		game.running = false

		game.tickCount = 0
		game.frameCount = 0

		return game
	end

	function Game:start()
		self.running = true

		Import(&quot;CLIENT_PACKET001_LOGIN&quot;)

		if not _G.isServer then
			self.packetHandler:sendPacket(CLIENT_PACKET001_LOGIN.new():Data())
		end

		coroutine.wrap(function()
			self:run()
		end)()
	end

	function Game:stop()
		self.running = false
		self.player:Destroy()
		self.screen.frame:Destroy()
		self.screen.ClippingMask:Destroy()
		local loaderInfo = Instance.new(&quot;TextLabel&quot;, self.canvas)
		loaderInfo.Size = UDim2.new(1,0,1,0)
		loaderInfo.BackgroundColor3 = Color3.new(0,0,0)
		loaderInfo.Text = &quot;You have lost connection&quot;
		loaderInfo.TextScaled = true
		loaderInfo.TextColor3 = Color3.new(0,0,0)
		loaderInfo.TextStrokeColor3 = Color3.new(141 / 255, 70 / 255, 212 / 255)
		loaderInfo.TextStrokeTransparency = 0
	end

	function Game:run()
		local timeAtStart = tick()
		local lastTime = tick()
		local minTimePerTick = 1/60
		local minTimePerFrame = 1/60

		local ticks = 0
		local frames = 0

		local lastTimer = tick()
		local unProcessedTime = 0
		local unRenderedTime = 0
		local lasttick = tick()
		--The game cycle (calls everything)
		
		_G.rbxGame:GetService(&quot;RunService&quot;).RenderStepped:connect(function()
		--while (self.running) do
			--[[local now = tick()
			unProcessedTime = unProcessedTime + ((now - lastTime) / minTimePerTick)
			unRenderedTime = unRenderedTime + ((now - lastTime) / minTimePerFrame)
			lastTime = now

			while (unProcessedTime &gt;= 1) do
				ticks = ticks + 1
				self:tick()
				unProcessedTime = unProcessedTime - 1
			end

			while (unRenderedTime &gt;= 1) do
				frames = frames + 1
				self:render()
				unRenderedTime = unRenderedTime - 1
			end

			wait(0)

			if (now - lastTimer &gt;= 1 ) then
				lastTimer = lastTimer + 1
				frames = 0
				ticks = 0
			end]]--
			
			self.deltaTime = tick() - lasttick
			self:tick(self.deltaTime)
			self:render(self.deltaTime)
			lasttick = tick()
		end)
	end

	function Game:tick(deltaTime)
		self.tickCount = self.tickCount + 1

		if self.player then
			self.player.level:tick(deltaTime)
		end

	end
	
	function Game:render(deltaTime)
		if not _G.isServer then
			self.frameCount = self.frameCount + 1

			if self.player then
				self.player.level:render(deltaTime)
				self.screen:render(deltaTime, self.player.posX - (self.screen.sizeX / 2), self.player.posY - (self.screen.sizeY / 2))
			end
		end
	end

end

Import(&quot;Server&quot;)

do --MAIN
	wait(2)
	if script.Parent.Parent.Name == &quot;Everest2DServer&quot; then
		Server.new()
		_G.isServer = true
		
		--Tell people that everest is loading when they join
		local loaderScreen = Instance.new(&quot;ScreenGui&quot;, game.StarterGui)
		local loaderInfo = Instance.new(&quot;TextLabel&quot;, loaderScreen)
		loaderInfo.Size = UDim2.new(1,0,1,0)
		loaderInfo.BackgroundColor3 = Color3.new(0,0,0)
		loaderInfo.Text = &quot;Please wait - Everest2D is loading&quot;
		loaderInfo.TextScaled = true
		loaderInfo.TextColor3 = Color3.new(0,0,0)
		loaderInfo.TextStrokeColor3 = Color3.new(141 / 255, 70 / 255, 212 / 255)
		loaderInfo.TextStrokeTransparency = 0
		--Stops people falling when they join
		local loaderBlock = Instance.new(&quot;Part&quot;, Workspace)
		loaderBlock.Anchored = true
		loaderBlock.Size = Vector3.new(100,10,100)
		loaderBlock.Position = Vector3.new(-50, -20, -50)
		wait(5)
	else
		Import(&quot;LocalPlayer&quot;)
		repeat wait() until game.Players.LocalPlayer.Character
		game.Players.LocalPlayer.Character:Destroy()
		game.StarterGui:SetCoreGuiEnabled(2, false)
		wait(5)
	end
	--waits for the server to start up (it creates the packethandler)
	repeat wait() until Workspace:FindFirstChild(&quot;PacketHandler&quot;)
	local game = Game.new()
	_G.localgame = game
	game:start()
end</ProtectedString>
          <Content name="LinkedSource">null</Content>
          <bool name="Disabled">false</bool>
        </Properties>
      </Item>
      <Item class="StringValue" referent="RBX0">
        <Properties>
          <string name="Name">level</string>
          <string name="Value"></string>
        </Properties>
        <Item class="LocalScript" referent="RBX0">
          <Properties>
            <string name="Name">TestLevel.lua</string>
            <ProtectedString name="Source">--A test map

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Level&quot;)
wait(1) --Wait for level to fully declare itself

local levelData = {}

--Example data structure

levelData[1]  = {4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4}
levelData[2]  = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[3]  = {4,1,1,1,1,1,1,1,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[4]  = {4,1,1,1,1,1,1,3,3,2,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[5]  = {4,1,1,1,1,1,3,3,2,5,2,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[6]  = {4,1,1,1,1,3,3,2,5,5,5,2,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[7]  = {4,1,1,1,1,3,2,5,5,5,5,5,2,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[8]  = {4,1,1,1,1,3,3,2,5,5,5,2,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[9]  = {4,1,1,1,1,1,3,3,2,5,2,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[10] = {4,1,1,1,1,1,1,3,3,2,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[11] = {4,1,1,1,1,1,1,1,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[12] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[13] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[14] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[15] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[16] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[17] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[18] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[19] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[20] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[21] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[22] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[23] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[24] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[25] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[26] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[27] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[28] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[29] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[30] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[31] = {4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4}
levelData[32] = {4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4}


Level.TestLevel = Level.new(500,500, nil, &quot;TestLevel&quot;):testRandomGenerate()

Level.ready = true</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
        <Item class="StringValue" referent="RBX0">
          <Properties>
            <string name="Name">tiles</string>
            <string name="Value"></string>
          </Properties>
          <Item class="LocalScript" referent="RBX0">
            <Properties>
              <string name="Name">AnimatedTile.lua</string>
              <ProtectedString name="Source">--Standard tile but with an animated texture

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Extends&quot;)
Import(&quot;BasicTile&quot;)


do AnimatedTile = Extends(&quot;AnimatedTile&quot;, BasicTile)

	--frames = total number of frames
	--delay = time between the frames
	function AnimatedTile.new(id, isWalkable, spriteSheet, spritePosX, spritePosY, frames, delay)
		local animatedTile = BasicTile.new(id, isWalkable, spriteSheet, spritePosX, spritePosY)
		setmetatable(animatedTile, AnimatedTile)
		
		animatedTile.frames = frames
		animatedTile.delay = delay
	
		return animatedTile
	end
	
	function AnimatedTile:render(screen, posX, posY)
	
		local rendered = Instance.new(&quot;ImageLabel&quot;, screen.frame)
		rendered.BorderSizePixel = 0
		rendered.ZIndex = 2
		rendered.Size = UDim2.new(0, 32, 0, 32)
		rendered.Position = UDim2.new(0, posX * 32, 0, posY * 32)
		rendered.Image = self.spriteSheet.url
		rendered.ImageRectSize = self.spriteSheet.vector2Size
		
		local currentFrame = math.floor((screen.game.tickCount / self.delay)) % self.frames
		local frameDir = 1
		local lastFrameTick = screen.game.tickCount
		
		--The loops which animates the tile
		coroutine.wrap(function()
		
			while wait() do
				--Synced with games tickcount for synced animation with other tiles
				currentFrame = math.floor(math.abs(math.sin(screen.game.tickCount / self.delay) * self.frames))
				
				lastFrameTick = screen.game.tickCount + self.delay
				
				--Gets the frames to the right of the spritePosX and spritePosY on the sprite required for the animation
				rendered.ImageRectOffset = Vector2.new(self.spritePosVec.X + (currentFrame * self.spriteSheet.vector2Size.X), self.spritePosVec.Y)
			end
			
		end)()
		
		return rendered
	end
	
	
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="LocalScript" referent="RBX0">
            <Properties>
              <string name="Name">Tile.lua</string>
              <ProtectedString name="Source">--Base tile, extend to make new tile types

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do Tile = Class(&quot;Tile&quot;)
	
	Tile.Tiles = {}
	
	function Tile.new(id, isWalkable)
		local tile = {}
		setmetatable(tile, Tile)		
		
		if Tile.Tiles[id] then error(&quot;Tile ID Conflict id: &quot; .. id) end
		Tile.Tiles[id] = tile
		
		tile.id = id
		tile.isWalkable = isWalkable
				
		return tile
	end
	
	function Tile:tick()
	
	end
	
	function Tile:render(screen, posX, posY)
		
		local rendered = Instance.new(&quot;ImageLabel&quot;, screen.frame)
		rendered.BorderSizePixel = 0
		rendered.ZIndex = 2
		rendered.Size = UDim2.new(0, 32, 0, 32)
		rendered.Position = UDim2.new(0, posX * 32, 0, posY * 32)
		rendered.Image = self.spriteSheet.url
		rendered.ImageRectSize = self.spriteSheet.vector2Size + Vector2.new(-2, -2)
		rendered.ImageRectOffset = self.spritePosVec + Vector2.new(1,1)
		
		
		return rendered
	end
	
	Import(&quot;BasicTile&quot;)
	Import(&quot;AnimatedTile&quot;)
	Import(&quot;SpriteSheet&quot;)
	
	--All tile types are declared here
	--id, walkable, spritesheet, spritesheetposition
	Tile.GRASS = BasicTile.new(1, true, SpriteSheet.BasicSpriteSheet, 0, 0)
	Tile.FLOWER1 = BasicTile.new(2, true, SpriteSheet.BasicSpriteSheet, 32, 0)
	Tile.FLOWER2 = BasicTile.new(3, true, SpriteSheet.BasicSpriteSheet, 64, 0)
	Tile.STONE = BasicTile.new(4, false, SpriteSheet.BasicSpriteSheet, 0, 32)
	Tile.Water = AnimatedTile.new(5, false, SpriteSheet.BasicSpriteSheet, 0, 64, 3, 60)
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="LocalScript" referent="RBX0">
            <Properties>
              <string name="Name">BasicTile.lua</string>
              <ProtectedString name="Source">--Basic general purpose tile

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Extends&quot;)
Import(&quot;Tile&quot;)

do BasicTile = Extends(&quot;BasicTile&quot;, Tile)
	
	function BasicTile.new(id, isWalkable, spriteSheet, spritePosX, spritePosY)
		basicTile = Tile.new(id, isWalkable)
		setmetatable(basicTile, BasicTile)
		
		basicTile.spriteSheet = spriteSheet
		basicTile.spritePosX = spritePosX
		basicTile.spritePosY = spritePosY
		basicTile.spriteSizeX = spriteSheet.spriteSizeX
		basicTile.spriteSizeY = spriteSheet.spriteSizeY	
		basicTile.spritePosVec = Vector2.new(spritePosX, spritePosY)
		
		return basicTile	
	end	
	
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
        </Item>
        <Item class="LocalScript" referent="RBX0">
          <Properties>
            <string name="Name">Level.lua</string>
            <ProtectedString name="Source">--Used to create the maps, extend this to make new ones

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do Level = Class(&quot;Level&quot;)
	
	Level.allLevels = {}
	
	function Level.new(width, height, tiles, name)
		local level = {}
		setmetatable(level, Level)
		
		level.width = width
		level.height = height
		level.tiles = tiles or {}
		level.entities = {}
		level.name = name
		
		Level.allLevels[name] = level
		
		if not tiles then
			for x = 0, level.width do
				level.tiles[x] = {}
			end	
		end	
		
		return level
	end
	
	function Level:tick()
		for _, entity in pairs(self.entities) do
			entity:tick()
		end
		
	end	
	
	function Level:render(deltaTime)
		for _, entity in pairs(self.entities) do
			entity:render(deltaTime)
		end
	end
	
	function Level:getEntityFromId(id)
		return self.entities[id]
	end
	
	Import(&quot;Tile&quot;)
	
	function Level:rayCast(pos, dirVec)
		for i = 1, 30 do
			local id = self.tiles[math.floor(pos.X + dirVec.X * i)] and self.tiles[math.floor(pos.X + dirVec.X * i)][math.floor(pos.Y + dirVec.Y * i)]
			if id then
				local tile = Tile.Tiles[id]
				if not tile.isWalkable then 
					return Vector2.new(pos.X + math.floor(dirVec.X * i), pos.Y + math.floor(dirVec.Y * i)) + Vector2.new(0.5,0.5) - dirVec
				end
			end
		end
		return pos + dirVec * 30
	end
	
	function Level:testRandomGenerate()
		
		repeat wait() until Tile.GRASS
		
		for x = 1, self.width do
			if x%100 == 0 then wait() print(x) end
			for y = 1, self.height do
				local rand = math.random(1, 30)
				if rand == 10  and y &gt; 2 then
					self.tiles[x][y] = Tile.FLOWER1.id
				elseif rand == 20 and y &gt; 2 then
					self.tiles[x][y] = Tile.FLOWER2.id
				elseif rand == 28 and y &gt; 2 then
					self.tiles[x][y] = Tile.GRASS.id
				else
					self.tiles[x][y] = Tile.GRASS.id
				end
			end
		end	
		
		self.ready = true
		return self
	end		
		
end

</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="StringValue" referent="RBX0">
    <Properties>
      <string name="Name">Everest2DServer</string>
      <string name="Value"></string>
    </Properties>
    <Item class="StringValue" referent="RBX0">
      <Properties>
        <string name="Name">server</string>
        <string name="Value"></string>
      </Properties>
      <Item class="StringValue" referent="RBX0">
        <Properties>
          <string name="Name">net</string>
          <string name="Value"></string>
        </Properties>
        <Item class="StringValue" referent="RBX0">
          <Properties>
            <string name="Name">packets</string>
            <string name="Value"></string>
          </Properties>
          <Item class="Script" referent="RBX0">
            <Properties>
              <string name="Name">SERVER_PACKET003_MOVE.lua</string>
              <ProtectedString name="Source">--server
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do SERVER_PACKET003_MOVE = Class(&quot;SERVER_PACKET003_MOVE&quot;)

	function SERVER_PACKET003_MOVE.new(entityLevelId, xa, ya, speed, posX, posY)
		local packet = {}
		setmetatable(packet, SERVER_PACKET003_MOVE)

		packet.entityLevelId = entityLevelId
		packet.xa = xa
		packet.ya = ya
		packet.speed = speed
		packet.posX = posX
		packet.posY = posY

		return packet
	end
	
	function SERVER_PACKET003_MOVE:Data()
		return {&quot;SERVER_PACKET003_MOVE&quot;, self.entityLevelId, self.xa, self.ya, self.speed, self.posX, self.posY}
	end
	
	
	function SERVER_PACKET003_MOVE.Handle(data)
		_G.localgame.player.level:getEntityFromId(data[2]):move(data[3], data[4], data[5], data[6], data[7])
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="Script" referent="RBX0">
            <Properties>
              <string name="Name">SERVER_PACKET002_SPAWN.lua</string>
              <ProtectedString name="Source">--server
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do SERVER_PACKET002_SPAWN = Class(&quot;SERVER_PACKET002_SPAWN&quot;)

	function SERVER_PACKET002_SPAWN.new(type, playerToSpawn, x, y, id)
		local packet = {}
		setmetatable(packet, SERVER_PACKET002_SPAWN)
		
		packet.type = type
		packet.playerToSpawn = playerToSpawn
		packet.x = x
		packet.y = y
		packet.id = id
		
		return packet
	end
	
	function SERVER_PACKET002_SPAWN:Data()
		return {&quot;SERVER_PACKET002_SPAWN&quot;, self.type, self.playerToSpawn.Name, self.x, self.y, self.id}
	end
	
	Import(&quot;Player&quot;)
	
	function SERVER_PACKET002_SPAWN.Handle(data)
		if data[2] == &quot;Player&quot; then
			p = Player.new(data[6], _G.localgame, _G.localgame.level, 100, data[3], data[4], data[5], nil)
		end
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="Script" referent="RBX0">
            <Properties>
              <string name="Name">SERVER_PACKET004_DISCONNECT.lua</string>
              <ProtectedString name="Source">--server
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do SERVER_PACKET004_DISCONNECT = Class(&quot;SERVER_PACKET004_DISCONNECT&quot;)

	function SERVER_PACKET004_DISCONNECT.new()
		local packet = {}
		setmetatable(packet, SERVER_PACKET004_DISCONNECT)


		return packet
	end
	
	function SERVER_PACKET004_DISCONNECT:Data()
		return {&quot;SERVER_PACKET004_DISCONNECT&quot;}
	end
	
	
	function SERVER_PACKET004_DISCONNECT.Handle(data)
		_G.localgame:stop()
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="Script" referent="RBX0">
            <Properties>
              <string name="Name">SERVER_PACKET001_START.lua</string>
              <ProtectedString name="Source">--server
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do SERVER_PACKET001_START = Class(&quot;SERVER_PACKET001_START&quot;)

	function SERVER_PACKET001_START.new(level, posX, posY, id)
		local packet = {}
		setmetatable(packet, SERVER_PACKET001_START)
		
		packet.level = level
		packet.posX = posX
		packet.posY = posY
		packet.id = id
		
		return packet
	end
	
	function SERVER_PACKET001_START:Data()
		return {&quot;SERVER_PACKET001_START&quot;, self.level, self.posX, self.posY, self.id}
	end
	
	Import(&quot;Level&quot;)
	Import(&quot;Player&quot;)
	Import(&quot;CLIENT_PACKET003_KEEPCONNECTION&quot;)
	
	function SERVER_PACKET001_START.Handle(data)
		coroutine.wrap(function() while wait(5) do _G.localgame.packetHandler:sendPacket(CLIENT_PACKET003_KEEPCONNECTION.new():Data()) end end)()
	
		_G.localgame.level = Level.allLevels[data[2]]
		repeat wait(1) until _G.localgame.level.ready
		_G.localgame.player = Player.new(data[5], _G.localgame, _G.localgame.level, 100, _G.localgame.localPlayer.Name, data[3], data[4], _G.localgame.inputHandler)
		
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="Script" referent="RBX0">
            <Properties>
              <string name="Name">SERVER_PACKET005_DISCONNECTOTHER.lua</string>
              <ProtectedString name="Source">--server
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do SERVER_PACKET005_DISCONNECTOTHER = Class(&quot;SERVER_PACKET005_DISCONNECTOTHER&quot;)

	function SERVER_PACKET005_DISCONNECTOTHER.new(playerName)
		local packet = {}
		setmetatable(packet, SERVER_PACKET005_DISCONNECTOTHER)

		packet.playerName = playerName

		return packet
	end
	
	function SERVER_PACKET005_DISCONNECTOTHER:Data()
		return {&quot;SERVER_PACKET005_DISCONNECTOTHER&quot;, self.playerName}
	end
	
	
	Import(&quot;Player&quot;)
	
	function SERVER_PACKET005_DISCONNECTOTHER.Handle(data)
		Player.players[data[2]]:Destroy()
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="Script" referent="RBX0">
            <Properties>
              <string name="Name">SERVER_PACKET006_SPAWNEFFECT.lua</string>
              <ProtectedString name="Source">--server
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do SERVER_PACKET006_SPAWNEFFECT = Class(&quot;SERVER_PACKET006_SPAWNEFFECT&quot;)

	function SERVER_PACKET006_SPAWNEFFECT.new(id, level, speed, posX, posY, type, dirVecX, dirVecY, size, color)
		local packet = {}
		setmetatable(packet, SERVER_PACKET006_SPAWNEFFECT)
		
		packet.id = id
		packet.level = level
		packet.speed = speed
		packet.posX = posX
		packet.posY = posY
		packet.type = type
		packet.dirVecX = dirVecX
		packet.dirVecY = dirVecY
		packet.size = size
		packet.color = color
		
		return packet
	end
	
	function SERVER_PACKET006_SPAWNEFFECT:Data()
		return {&quot;SERVER_PACKET006_SPAWNEFFECT&quot;, 
				self.id,
				self.level,
				self.speed,
				self.posX,
				self.posY,
				self.type,
				self.dirVecX,
				self.dirVecY,
				self.size,
				self.color}
	end
	
	Import(&quot;BasicMissile&quot;)
	Import(&quot;Level&quot;)
	function SERVER_PACKET006_SPAWNEFFECT.Handle(data)
		if data[7] == &quot;BasicMissile&quot; then
			BasicMissile.new(data[2],Level.allLevels[data[3]],data[4],data[5],data[6],data[7],Vector2.new(data[8],data[9]),data[10],data[11])
		end
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
        </Item>
        <Item class="Script" referent="RBX0">
          <Properties>
            <string name="Name">ServerPacketHandler.lua</string>
            <ProtectedString name="Source">--server
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do ServerPacketHandler = Class(&quot;ServerPacketHandler&quot;)

	function ServerPacketHandler.new(server)
		local serverPacketHandler = {}
		setmetatable(serverPacketHandler, ServerPacketHandler)
		
		serverPacketHandler.server = server
		serverPacketHandler.handle = Instance.new(&quot;RemoteFunction&quot;, Workspace)
		serverPacketHandler.handle.Name = &quot;PacketHandler&quot;
		
		function serverPacketHandler.handle.OnServerInvoke(player, data)
			serverPacketHandler:receivedPacket(player, data)
		end
		
		return serverPacketHandler
	end
	
	function ServerPacketHandler:sendPacket(player, data)
		local stringData = &quot;&quot;
		for _, v in pairs(data) do stringData = stringData .. &quot; &quot; .. tostring(v) end
		--print(tick() .. &quot;: Server sending packet &quot; .. stringData .. &quot; to player &quot; .. player.Name)
		coroutine.wrap(function(player, data)
			self.handle:InvokeClient(player, data)
		end)(player, data)
		data = nil
	end
	
	Import(&quot;CLIENT_PACKET001_LOGIN&quot;)
	Import(&quot;CLIENT_PACKET002_MOVE&quot;)
	Import(&quot;CLIENT_PACKET003_KEEPCONNECTION&quot;)
	Import(&quot;CLIENT_PACKET004_SPAWNEFFECT&quot;)
	function ServerPacketHandler:receivedPacket(player, data)
		local stringData = &quot;&quot;
		for _, v in pairs(data) do stringData = stringData .. &quot; &quot; .. tostring(v) end
		--print(tick() .. &quot;: Server received packet &quot; .. stringData .. &quot; from player &quot; .. player.Name)
		getfenv()[data[1]].Handle(player, data)
		data = nil
	end
	
end</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
      </Item>
      <Item class="Script" referent="RBX0">
        <Properties>
          <string name="Name">Server.lua</string>
          <ProtectedString name="Source">--Handles entity ai, player positions, chat, etc.

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do Server = Class(&quot;Server&quot;)

	Import(&quot;ServerPacketHandler&quot;)
	function Server.new()
		print(&quot;!!!SERVER INITIALISING!!!&quot;)
		local server = {}
		setmetatable(server, Server)

		_G.localserver = server
		server.packetHandler = ServerPacketHandler.new(server)
		server.players = {}
		server.playersLastConnect = {}

		return server
	end

end
</ProtectedString>
          <Content name="LinkedSource">null</Content>
          <bool name="Disabled">false</bool>
        </Properties>
      </Item>
    </Item>
    <Item class="StringValue" referent="RBX0">
      <Properties>
        <string name="Name">game</string>
        <string name="Value"></string>
      </Properties>
      <Item class="Script" referent="RBX0">
        <Properties>
          <string name="Name">InputHandler.lua</string>
          <ProtectedString name="Source">--Custom input handler for convenience

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do InputHandler = Class(&quot;InputHandler&quot;)
	
	function InputHandler.new(game)
		local inputHandler = {}
		setmetatable(inputHandler, InputHandler)		
		
		inputHandler.keys = {}
		inputHandler.mouse = game.localPlayer:GetMouse()		
		
		--Allows to easily see which keys are being held down
		inputHandler.mouse.KeyDown:connect(function(key) inputHandler:keyDown(key) end)		
		inputHandler.mouse.KeyUp:connect(function(key) inputHandler:keyUp(key) end)		
		inputHandler.mouse.Button1Down:connect(function() inputHandler:keyDown(&quot;Button1&quot;) end)
		inputHandler.mouse.Button1Up:connect(function() inputHandler:keyUp(&quot;Button1&quot;) end)	
		
		return inputHandler
	end
	
	function InputHandler:keyDown(key)
		self.keys[key] = true
	end
	
	function InputHandler:keyUp(key)
		self.keys[key] = false		
	end
end</ProtectedString>
          <Content name="LinkedSource">null</Content>
          <bool name="Disabled">false</bool>
        </Properties>
      </Item>
      <Item class="StringValue" referent="RBX0">
        <Properties>
          <string name="Name">util</string>
          <string name="Value"></string>
        </Properties>
        <Item class="Script" referent="RBX0">
          <Properties>
            <string name="Name">Import.lua</string>
            <ProtectedString name="Source">--Allows you to import a class (this was made before modulescripts)

function _G.Import(toImport)
	print(&quot;IMPORTING &quot; .. toImport)
	wait()
	if not _G[toImport] then
		repeat wait(0.1) print(&quot;STILL IMPORTING &quot; .. toImport) 
		until _G[toImport]
	end
	getfenv(2)[toImport] = _G[toImport]
end
</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
        <Item class="Script" referent="RBX0">
          <Properties>
            <string name="Name">LocalPlayer.lua</string>
            <ProtectedString name="Source">--client

--Just a reference for the localplayer incase it gets lost

_G.LocalPlayer = game.Players.LocalPlayer</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
        <Item class="Script" referent="RBX0">
          <Properties>
            <string name="Name">Class.lua</string>
            <ProtectedString name="Source">
function _G.Class(className)
	local class = {}
	_G[className] = class
	class.__Index = class
	
	return class
end</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
        <Item class="Script" referent="RBX0">
          <Properties>
            <string name="Name">Extends.lua</string>
            <ProtectedString name="Source">--client

--allows a class to extend another

function _G.Extends(className, toExtend)
	local extendee = {}
	setmetatable(extendee, toExtend)
	
	_G[className] = extendee
	extendee.__Index = extendee
	
	return extendee
end</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
      </Item>
      <Item class="StringValue" referent="RBX0">
        <Properties>
          <string name="Name">graphics</string>
          <string name="Value"></string>
        </Properties>
        <Item class="Script" referent="RBX0">
          <Properties>
            <string name="Name">Screen.lua</string>
            <ProtectedString name="Source">--This is essentially the camera

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(Class)

do Screen = Class(&quot;Screen&quot;)

	Import(&quot;Hud&quot;)

	function Screen.new(game, sizeX, sizeY)
		local screen = {}
		setmetatable(screen, Screen)

		screen.ClippingMask = Instance.new(&quot;Frame&quot;, game.canvas)
		screen.ClippingMask.Size = UDim2.new(1,0,1,0)
		screen.ClippingMask.BackgroundColor3 = Color3.new(0,0,0)
		screen.ClippingMask.BackgroundTransparency = 0
		screen.ClippingMask.Name = &quot;Clipping Mask&quot;

		screen.frame = Instance.new(&quot;Frame&quot;, game.canvas)
		screen.frame.Size = UDim2.new(1,0,1,0)
		screen.frame.ZIndex = 2
		screen.frame.BackgroundTransparency = 1
		screen.frame.Name = &quot;Screen&quot;
		screen.testFrame = Instance.new(&quot;Frame&quot;, screen.frame)
		screen.testFrame.Size = UDim2.new(0,10,0,10)
		screen.testFrame.ZIndex = 6
		screen.testFrame.BackgroundTransparency = 0
		screen.testFrame.Name = &quot;testFrame&quot;
		
		screen.posX = 0
		screen.posY = 0
		
		screen.game = game
		screen.sizeX = sizeX
		screen.sizeY = sizeY
		screen.rendered = {}
		
		screen.hud = Hud.new(screen)
		
		
		return screen
	end

	Import(&quot;Tile&quot;)

	--Warning dense code ahead!
	function Screen:render(deltaTime, posX, posY)

		--Waits for the level to load itself
		while not self.game.level.ready and not #Tile.Tiles &gt; 0 do wait() end
		
		--Stops the screen from moving over the edge of the map
		posX = math.min(self.game.level.width - 1 - (self.sizeX), posX)
		posY = math.min(self.game.level.height - 1 - (self.sizeY), posY)
		posX = math.max(1, posX)
		posY = math.max(1, posY)
		
		self.posX = posX
		self.posY = posY
		
		local posVec = Vector2.new(-posX * 32, -posY * 32)
		local currentPosVec = Vector2.new(self.frame.AbsolutePosition.X, self.frame.AbsolutePosition.Y)
		
		local newPos = currentPosVec:lerp(posVec, 8 * deltaTime)
		
		self.frame.Position = UDim2.new(0, newPos.X, 0, newPos.Y)

		local used = {}
		
		--Rounded so it matched up with the levels integer positions
		posX = math.floor(posX)
		posY = math.floor(posY)

		--Loops the size of the screen plus 1/4 over the edges
		for x = math.floor(-self.sizeX / 4), math.floor(self.sizeX + self.sizeY / 4) do
			for y = math.floor(-self.sizeY / 4), math.floor(self.sizeY + self.sizeY / 4) do
				local posXX = math.min(self.game.level.width, posX + x)
				local posYY = math.min(self.game.level.height, posY + y)
				posXX = math.max(1, posXX)
				posYY = math.max(1, posYY)

				self.rendered[posXX] = self.rendered[posXX] or {}
				used[posXX] = used[posXX] or {}
				used[posXX][posYY] = true
				
				--Checks if this tile has already been rendered, if not it renders it
				if not self.rendered[posXX][posYY] then
					if self.game.level.tiles[posXX] and self.game.level.tiles[posXX][posYY] then
						self.rendered[posXX][posYY] = Tile.Tiles[self.game.level.tiles[posXX][posYY]]:render(self, posXX, posYY)
					end
				end
			end
		end
		
		--Checks the rendered tiles to see if they still need to be rendered
		--I.E removes tiles that are not on the screen
		for x, ytab in pairs(self.rendered) do
			for y, tile in pairs(ytab) do
				if not used[x] then
					for y, tile in pairs(ytab) do
						tile:Destroy()
						self.rendered[x][y] = nil
					end
					self.rendered[x] = nil
					used[x] = nil
					break
				elseif not used[x][y] then
					tile:Destroy()
					self.rendered[x][y] = nil
					used[x][y] = nil
				end
			end
		end

	end
end</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
        <Item class="Script" referent="RBX0">
          <Properties>
            <string name="Name">Hud.lua</string>
            <ProtectedString name="Source">--Heads up display

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do Hud = Class(&quot;Hud&quot;)
	
	function Hud.new(screen)
		local hud = {}
		setmetatable(hud, Hud)
		
		hud.screen = screen
		hud.frame = Instance.new(&quot;Frame&quot;, screen.frame.Parent)
		hud.frame.Size = UDim2.new(1,0,1,0)
		hud.frame.ZIndex = 9
		hud.frame.BackgroundTransparency = 1
		hud.frame.Name = &quot;Hud&quot;
		
		hud.playerInfo = Instance.new(&quot;ImageLabel&quot;, hud.frame)
		hud.playerInfo.Size = UDim2.new(0, 300, 0, 100)
		hud.playerInfo.BackgroundTransparency = 1
		hud.playerInfo.BackgroundColor3 = Color3.new(0,0,0)
		hud.playerInfo.Name = &quot;PlayerInfo&quot;
		hud.playerInfo.Image = &quot;http://www.roblox.com/asset/?id=135283499&quot;
		hud.playerInfo.ZIndex = 9
		
		hud.playerName = Instance.new(&quot;TextLabel&quot;, hud.playerInfo)
		hud.playerName.Size = UDim2.new(0,120,0,20)
		hud.playerName.Position = UDim2.new(0,90,0,24)
		hud.playerName.BackgroundTransparency = 1
		hud.playerName.Text = screen.game.localPlayer.Name
		hud.playerName.TextXAlignment = &quot;Left&quot;
		hud.playerName.TextScaled = true
		hud.playerName.FontSize = &quot;Size24&quot;
		hud.playerName.Font = &quot;ArialBold&quot;
		hud.playerName.TextColor3 = Color3.new(1,1,1)
		hud.playerName.TextStrokeTransparency = 0
		hud.playerName.Name = &quot;PlayerName&quot;
		hud.playerName.ZIndex = 9
		
		hud.playerHealth = Instance.new(&quot;TextLabel&quot;, hud.playerInfo)
		
		
		
		return hud
	end
	
end</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
        <Item class="Script" referent="RBX0">
          <Properties>
            <string name="Name">SpriteSheet.lua</string>
            <ProtectedString name="Source">--Simplified images

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do SpriteSheet = Class(&quot;SpriteSheet&quot;)
	
	function SpriteSheet.new(name, urlId, spriteSizeX, spriteSizeY)
		local spriteSheet = {}
		setmetatable(spriteSheet, SpriteSheet)
	
		spriteSheet.name = name
		spriteSheet.url = &quot;http://www.roblox.com/asset/?id=&quot; .. urlId
		spriteSheet.spriteSizeX = spriteSizeX
		spriteSheet.spriteSizeY = spriteSizeY
		spriteSheet.vector2Size = Vector2.new(spriteSizeX, spriteSizeY)
	
		return spriteSheet
	end
	
	SpriteSheet.BasicSpriteSheet = SpriteSheet.new(&quot;basic&quot;, 134517395, 32, 32)		
	
end</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
      </Item>
      <Item class="StringValue" referent="RBX0">
        <Properties>
          <string name="Name">net</string>
          <string name="Value"></string>
        </Properties>
        <Item class="StringValue" referent="RBX0">
          <Properties>
            <string name="Name">packets</string>
            <string name="Value"></string>
          </Properties>
          <Item class="Script" referent="RBX0">
            <Properties>
              <string name="Name">CLIENT_PACKET001_LOGIN.lua</string>
              <ProtectedString name="Source">--client

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do CLIENT_PACKET001_LOGIN = Class(&quot;CLIENT_PACKET001_LOGIN&quot;)

	function CLIENT_PACKET001_LOGIN.new()
		local packet = {}
		setmetatable(packet, CLIENT_PACKET001_LOGIN)

		return packet
	end

	function CLIENT_PACKET001_LOGIN:Data()
		return {&quot;CLIENT_PACKET001_LOGIN&quot;}
	end

	Import(&quot;Player&quot;)
	Import(&quot;Level&quot;)
	Import(&quot;SERVER_PACKET001_START&quot;)
	Import(&quot;SERVER_PACKET002_SPAWN&quot;)
	Import(&quot;SERVER_PACKET004_DISCONNECT&quot;)
	Import(&quot;SERVER_PACKET005_DISCONNECTOTHER&quot;)

	function CLIENT_PACKET001_LOGIN.Handle(player, data)

		_G.localserver.players[player] = {lastInteracted = tick(), player = Player.new(nil, _G.localgame, Level.allLevels[&quot;TestLevel&quot;], 100, player.Name, 5, 5, nil)}
		_G.localserver.packetHandler:sendPacket(player, SERVER_PACKET001_START.new(&quot;TestLevel&quot;, 5, 5, _G.localserver.players[player].player.levelId):Data())
		
		for playerToSpawn, playerInTable in pairs(_G.localserver.players) do
			if playerToSpawn ~= player then
				_G.localserver.packetHandler:sendPacket(player, 
					SERVER_PACKET002_SPAWN.new(&quot;Player&quot;, playerToSpawn, playerInTable.player.posX, playerInTable.player.posY, _G.localserver.players[playerToSpawn].player.levelId):Data())
			end
		end

		for playerToSend, _ in pairs(_G.localserver.players) do
			if playerToSend ~= player then
				_G.localserver.packetHandler:sendPacket(playerToSend, SERVER_PACKET002_SPAWN.new(&quot;Player&quot;, player, 5, 5, _G.localserver.players[player].player.levelId):Data())
			end
		end
		
		
		
		coroutine.wrap(function() 
			repeat 
				wait(10) 
			until _G.localserver.players[player].lastInteracted + 10 &lt; tick() 
			print(&quot;Disconnecting player &quot; .. player.Name .. &quot; due to lost connection.&quot;)
			_G.localserver.packetHandler:sendPacket(player, SERVER_PACKET004_DISCONNECT.new():Data())
			for playerTo, _ in pairs(_G.localserver.players) do
				if playerTo ~= player then
					_G.localserver.packetHandler:sendPacket(playerTo, SERVER_PACKET005_DISCONNECTOTHER.new(player.Name):Data())
				end
			end
			_G.localserver.players[player] = nil
		end)()
		
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="Script" referent="RBX0">
            <Properties>
              <string name="Name">CLIENT_PACKET004_SPAWNEFFECT.lua</string>
              <ProtectedString name="Source">--client

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do CLIENT_PACKET004_SPAWNEFFECT = Class(&quot;CLIENT_PACKET004_SPAWNEFFECT&quot;)

	function CLIENT_PACKET004_SPAWNEFFECT.new(id, level, speed, posX, posY, type, dirVec, size, color)
		local packet = {}
		setmetatable(packet, CLIENT_PACKET004_SPAWNEFFECT)
		
		packet.id = id
		packet.level = level
		packet.speed = speed
		packet.posX = posX
		packet.posY = posY
		packet.type = type
		packet.dirVec = dirVec
		packet.size = size
		packet.color = color
		
		return packet
	end

	function CLIENT_PACKET004_SPAWNEFFECT:Data()
		return {&quot;CLIENT_PACKET004_SPAWNEFFECT&quot;, 
				self.id,
				self.level.name,
				self.speed,
				self.posX,
				self.posY,
				self.type,
				self.dirVec.X,
				self.dirVec.Y,
				self.size,
				self.color}
	end

	Import(&quot;SERVER_PACKET006_SPAWNEFFECT&quot;)

	function CLIENT_PACKET004_SPAWNEFFECT.Handle(player, data)
		for playerToSend, _ in pairs(_G.localserver.players) do
			if playerToSend ~= player then
				_G.localserver.packetHandler:sendPacket(playerToSend, 
					SERVER_PACKET006_SPAWNEFFECT.new(data[2],data[3],data[4],data[5],data[6],data[7],data[8],data[9],data[10],data[11]):Data())
			end
		end
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="Script" referent="RBX0">
            <Properties>
              <string name="Name">CLIENT_PACKET002_MOVE.lua</string>
              <ProtectedString name="Source">--client

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do CLIENT_PACKET002_MOVE = Class(&quot;CLIENT_PACKET002_MOVE&quot;)

	function CLIENT_PACKET002_MOVE.new(id, xa, ya, speed, posX, posY)
		local packet = {}
		setmetatable(packet, CLIENT_PACKET002_MOVE)

		packet.id = id
		packet.xa = xa
		packet.ya = ya
		packet.speed = speed
		packet.posX = posX
		packet.posY = posY

		return packet
	end

	function CLIENT_PACKET002_MOVE:Data()
		return {&quot;CLIENT_PACKET002_MOVE&quot;, self.id, self.xa, self.ya, self.speed, self.posX, self.posY}
	end

	Import(&quot;SERVER_PACKET003_MOVE&quot;)

	function CLIENT_PACKET002_MOVE.Handle(player, data)
		for playerTo, _ in pairs(_G.localserver.players) do
			if playerTo ~= player then
				_G.localserver.packetHandler:sendPacket(playerTo, SERVER_PACKET003_MOVE.new(data[2], data[3], data[4], data[5], _G.localserver.players[player].player.posX, _G.localserver.players[player].player.posY):Data())
			end
		end

		_G.localserver.players[player].player.posX = _G.localserver.players[player].player.posX + (data[3] * data[5])
		_G.localserver.players[player].player.posY = _G.localserver.players[player].player.posY + (data[4] * data[5])
		_G.localserver.players[player].lastInteracted = tick()

		if data[6] ~= _G.localserver.players[player].player.posX or data[7] ~= _G.localserver.players[player].player.posY then
			_G.localserver.packetHandler:sendPacket(player, SERVER_PACKET003_MOVE.new(data[2], data[3], 0, 0, _G.localserver.players[player].player.posX, _G.localserver.players[player].player.posY):Data())
		end
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="Script" referent="RBX0">
            <Properties>
              <string name="Name">CLIENT_PACKET003_KEEPCONNECTION.lua</string>
              <ProtectedString name="Source">--client

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do CLIENT_PACKET003_KEEPCONNECTION = Class(&quot;CLIENT_PACKET003_KEEPCONNECTION&quot;)

	function CLIENT_PACKET003_KEEPCONNECTION.new()
		local packet = {}
		setmetatable(packet, CLIENT_PACKET003_KEEPCONNECTION)

		return packet
	end

	function CLIENT_PACKET003_KEEPCONNECTION:Data()
		return {&quot;CLIENT_PACKET003_KEEPCONNECTION&quot;}
	end

	function CLIENT_PACKET003_KEEPCONNECTION.Handle(player, data)
		_G.localserver.players[player].lastInteracted = tick()
	end
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
        </Item>
        <Item class="Script" referent="RBX0">
          <Properties>
            <string name="Name">ClientPacketHandler.lua</string>
            <ProtectedString name="Source">--client
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do ClientPacketHandler = Class(&quot;ClientPacketHandler&quot;)

	function ClientPacketHandler.new(game)
		local clientPacketHandler = {}
		setmetatable(clientPacketHandler, ClientPacketHandler)
		
		clientPacketHandler.game = game
		clientPacketHandler.handle = Workspace.PacketHandler
		
		function clientPacketHandler.handle.OnClientInvoke(data)
			clientPacketHandler:receivedPacket(data)
		end
		
		return clientPacketHandler
	end
	
	function ClientPacketHandler:sendPacket(data)
		local stringData = &quot;&quot;
		for _, v in pairs(data) do stringData = stringData .. &quot; &quot; .. tostring(v) end
		--print(tick() .. &quot;: Client sending packet &quot; .. stringData)
		coroutine.wrap(function(data)
			self.handle:InvokeServer(data)
		end)(data)
		data = nil
	end
	
	Import(&quot;SERVER_PACKET001_START&quot;)
	Import(&quot;SERVER_PACKET002_SPAWN&quot;)
	Import(&quot;SERVER_PACKET003_MOVE&quot;)
	Import(&quot;SERVER_PACKET004_DISCONNECT&quot;)
	Import(&quot;SERVER_PACKET005_DISCONNECTOTHER&quot;)
	Import(&quot;SERVER_PACKET006_SPAWNEFFECT&quot;)
	function ClientPacketHandler:receivedPacket(data)
		local stringData = &quot;&quot;
		for _, v in pairs(data) do stringData = stringData .. &quot; &quot; .. tostring(v) end
		--print(tick() .. &quot;: Client received packet &quot; .. stringData)
		getfenv()[data[1]].Handle(data)
		data = nil
	end
	
end</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
      </Item>
      <Item class="StringValue" referent="RBX0">
        <Properties>
          <string name="Name">entities</string>
          <string name="Value"></string>
        </Properties>
        <Item class="StringValue" referent="RBX0">
          <Properties>
            <string name="Name">mobs</string>
            <string name="Value"></string>
          </Properties>
          <Item class="Script" referent="RBX0">
            <Properties>
              <string name="Name">Player.lua</string>
              <ProtectedString name="Source">--Player class, all players use this class

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Extends&quot;)
Import(&quot;Mob&quot;)

do Player = Extends(&quot;Player&quot;, Mob)
		
	Import(&quot;SpriteSheet&quot;)
	
	Player.players = {}
	
	function Player.new(id, game, level, health, name, posX, posY, input)
		local player = Mob.new(id, game, level, health, name, 0.3		, posX, posY, &quot;PLAYER&quot;)
		setmetatable(player, Player)
		
		
		if name == game.localPlayer.Name then
			player.frame.ZIndex = 6
		end
		
		player.input = input	
		player.scale = 2
		player.game = game
		player.frame.Name = name
		player.frame.Image = SpriteSheet.BasicSpriteSheet.url
		player.frame.ImageRectSize = Vector2.new(32, 32)
		player.frame.ImageRectOffset = Vector2.new(0, 128)
		
		Player.players[name] = player
		
		return player
	end
	
	Import(&quot;CLIENT_PACKET002_MOVE&quot;)
	Import(&quot;CLIENT_PACKET004_SPAWNEFFECT&quot;)
	Import(&quot;BasicMissile&quot;)
	
	function Player:tick()
		local xa = 0
		local ya = 0
		
		if self.input then
			if self.input.keys[&quot;w&quot;] then
				ya = ya - 1
			end
			if self.input.keys[&quot;s&quot;] then
				ya = ya + 1
			end
			if self.input.keys[&quot;a&quot;] then
				xa = xa - 1
			end
			if self.input.keys[&quot;d&quot;] then
				xa = xa + 1
			end
			if self.input.keys[&quot;Button1&quot;] then
				local mousePos = Vector2.new((self.input.mouse.X + _G.localgame.screen.posX * 32)/32, (self.input.mouse.Y + _G.localgame.screen.posY * 32)/32)
				local dirVec = (mousePos - Vector2.new(self.posX, self.posY)).unit
				local missile = BasicMissile.new(#self.level.entities + 1, self.level, 3, self.posX, self.posY, &quot;BasicMissile&quot;, dirVec, UDim2.new(0, 10, 0, 10), Color3.new(0,191/255,1))
				self.game.packetHandler:sendPacket(CLIENT_PACKET004_SPAWNEFFECT.new(#self.level.entities + 1, self.level, 3, self.posX, self.posY, &quot;BasicMissile&quot;, dirVec, UDim2.new(0, 10, 0, 10), Color3.new(255/255,50/255,50/255)):Data())
			end
		end
		
		if xa ~= 0 or ya ~= 0 then
			xa, ya = self:move(xa, ya)
			
			xa = xa or 0
			ya = ya or 0
			
			self.isMoving = true
			self.game.packetHandler:sendPacket(CLIENT_PACKET002_MOVE.new(self.levelId, xa, ya, self.speed, self.posX, self.posY):Data())
		else
			self.isMoving = false
		end
		
	end	
	
	function Player:render(deltaTime)
		local animCycle = 2 - math.floor((self.numSteps * (self.speed * 5)) % 30 / 10)	
		
		
		local posVec = Vector2.new(self.posX * 32, self.posY * 32)
		local currentPosVec = Vector2.new(self.frame.AbsolutePosition.X, self.frame.AbsolutePosition.Y)
		
		local newPos = currentPosVec:lerp(posVec, 8 * deltaTime)
		
		self.frame.Position = UDim2.new(0, posVec.X, 0, posVec.Y)
		
		self.frame:TweenSize(UDim2.new(0, 32 * self.scale, 0, 32 * self.scale), &quot;Out&quot;, &quot;Linear&quot;, 0.2, true)
		
		if self.movingDir == &quot;NORTH&quot; then
			self.frame.ImageRectOffset = Vector2.new(32 * animCycle, 225)
			self.frame.ImageRectSize = Vector2.new(31, 31)
		end
		if self.movingDir == &quot;EAST&quot; then
			self.frame.ImageRectOffset = Vector2.new(32 * animCycle, 193)
			self.frame.ImageRectSize = Vector2.new(31, 31)			
		end
		if self.movingDir == &quot;SOUTH&quot; then
			self.frame.ImageRectOffset = Vector2.new(32 * animCycle, 129)
			self.frame.ImageRectSize = Vector2.new(31, 31)
		end
		if self.movingDir == &quot;WEST&quot; then
			self.frame.ImageRectOffset = Vector2.new(32 * animCycle, 161)
			self.frame.ImageRectSize = Vector2.new(31, 31)			
		end
	end
	
	function Player:hasCollided(xa, ya)
		return self:isSolidTile(self.posX, self.posY, xa, ya)	
	end
	
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="Script" referent="RBX0">
            <Properties>
              <string name="Name">Mob.lua</string>
              <ProtectedString name="Source">--Base mob class, mobs should extend this class

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Extends&quot;)
Import(&quot;Entity&quot;)

do Mob = Extends(&quot;Mob&quot;, Entity)

	function Mob.new(id, game, level, hp, name, speed, posX, posY, type)
		local mob = Entity.new(id, level, posX, posY)
		setmetatable(mob, Mob)

		mob.name = name
		mob.hp = hp
		mob.speed = speed
		mob.type = type
		mob.numSteps = 0
		mob.isMoving = false
		mob.movingDir = &quot;SOUTH&quot;
		mob.scale = 1
		mob.frame = Instance.new(&quot;ImageLabel&quot;, game.screen.frame)
		mob.frame.BorderSizePixel = 0
		mob.frame.BackgroundTransparency = 1
		mob.frame.ZIndex = 5

		mob.nameToolTip = Instance.new(&quot;TextLabel&quot;, mob.frame)
		mob.nameToolTip.Text = name .. &quot;:&quot; .. mob.levelId
		mob.nameToolTip.Size = UDim2.new(1,0,0.3,0)
		mob.nameToolTip.Position = UDim2.new(0,0,-0.5,0)
		mob.nameToolTip.BackgroundTransparency = 1
		mob.nameToolTip.BorderSizePixel = 0
		mob.nameToolTip.FontSize = &quot;Size18&quot;
		mob.nameToolTip.ZIndex = 8

		return mob
	end

	--xa is the distance across x it is moving
	--xy is the same for the y axis
	--type is the speed at which they move
	--truePosX is for synchronisation with the server (forces the entity to that position)
	--truePosY is the same but for the y axis
	function Mob:move(xa, ya, type, truePosX, truePosY)
	
		self.posX = truePosX or self.posX
		self.posY = truePosY or self.posY
	
		if xa ~= 0 and ya ~= 0 then
			xa = xa * math.cos(45)
			ya = ya * math.cos(45)
		end

		self.numSteps = self.numSteps + 1

		if not self:hasCollided(xa, ya) then

			if ya &lt; 0 then self.movingDir = &quot;NORTH&quot; end
			if ya &gt; 0 then self.movingDir = &quot;SOUTH&quot; end
			if xa &lt; 0 then self.movingDir = &quot;WEST&quot; end
			if xa &gt; 0 then self.movingDir = &quot;EAST&quot; end

			self.posX = math.min(self.posX + (xa * self.speed), self.level.width)
			self.posX = math.max(self.posX, 0)
			self.posY = math.min(self.posY + (ya * self.speed), self.level.height)
			self.posY = math.max(self.posY, 0)

			self.currentTile = self.level.tiles[math.floor(self.posX + 0.5)][math.floor(self.posY + 0.5)]

			return xa, ya
		end

	end

	--Should be custom for every mob due to differing behavour
	function Mob:hasCollided()
		error(&quot;Attempted to call hasCollided on native mob class.&quot;)
	end

	Import(&quot;Tile&quot;)

	--Find if the mob moving from x,y via xa ya will collide with a tile
	--Factors in the scale of the mob
	function Mob:isSolidTile(x, y, xa, ya)

		local x = math.max(0, math.floor(x + xa))
		local x = math.min(self.level.width, x)
		local y = math.max(0, math.floor(y + ya))
		local y = math.min(self.level.height, y)

		local solid = false
		if x &gt;= self.level.width - 1 or x &lt;= 0 or y &gt;= self.level.height - 1 or y &lt;= 0 then return true end
		for xi = 0, math.ceil(self.scale) do
			for yi = 0, math.ceil(self.scale) do
				local nextTile = Tile.Tiles[self.level.tiles[x + xi][y + yi]]
				if not nextTile.isWalkable then solid = true end
			end
		end
		local nextTile = Tile.Tiles[self.level.tiles[x][y]]

		return solid

	end

end
</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
        </Item>
        <Item class="Script" referent="RBX0">
          <Properties>
            <string name="Name">Entity.lua</string>
            <ProtectedString name="Source">--Base entity class, should not really be used for anything other than setting up other classes

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do Entity = Class(&quot;Entity&quot;)
	
	function Entity.new(id, level, posX, posY)
		entity = {}
		setmetatable(entity, Entity)
		
		entity.level = level
		if id then
			level.entities[id] = entity
			entity.levelId = id
		else
			table.insert(level.entities, entity)
			entity.levelId = #level.entities
		end
		entity.posX = posX
		entity.posY = posY
		
		return entity
	end
	
	function Entity:tick()
		
	end
	
	function Entity:render()
		--Entities should have their own render function due to graphical diversity
		error(&quot;Attempted to render base entity&quot;)
	end	
	
	function Entity:Destroy()
		self.level.entities[self.levelId] = nil
		if self.frame then
			self.frame:Destroy()
		end
		self = nil
	end
	
end</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
        <Item class="StringValue" referent="RBX0">
          <Properties>
            <string name="Name">effects</string>
            <string name="Value"></string>
          </Properties>
          <Item class="Script" referent="RBX0">
            <Properties>
              <string name="Name">BasicMissile.lua</string>
              <ProtectedString name="Source">--client
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Extends&quot;)
Import(&quot;Entity&quot;)

do BasicMissile = Extends(Entity)
	_G.BasicMissile = BasicMissile
	BasicMissile.__index = BasicMissile

	function BasicMissile.new(id, level, speed, posX, posY, type, dirVec, size, color)
		local basicMissile = Entity.new(id, level, posX, posY)
		setmetatable(basicMissile, BasicMissile)

		basicMissile.speed = speed
		basicMissile.type = type
		basicMissile.movingDir = movingDir
		basicMissile.size = size
		basicMissile.color = color
		basicMissile.frame = Instance.new(&quot;ImageLabel&quot;, _G.localgame.screen.frame)
		basicMissile.frame.Name = &quot;testBasicMissile&quot;
		basicMissile.frame.Size = size
		basicMissile.frame.BorderSizePixel = 0
		basicMissile.frame.BackgroundTransparency = 0
		basicMissile.frame.ZIndex = 5
		basicMissile.frame.Position = UDim2.new(0, posX * 32, 0, posY * 32)
		basicMissile.frame.BackgroundColor3 = color
		basicMissile.endPos = basicMissile.level:rayCast(Vector2.new(posX, posY), dirVec)
		local timeToTake = (Vector2.new(posX, posY) - basicMissile.endPos).magnitude^.5 / speed
		basicMissile.frame:TweenPosition(UDim2.new(0, basicMissile.endPos.X * 32, 0, basicMissile.endPos.Y * 32), &quot;Out&quot;, &quot;Linear&quot;, timeToTake, true)
		coroutine.wrap(function() 
			while basicMissile do 
				wait()
				local particle = Instance.new(&quot;ImageLabel&quot;, _G.localgame.screen.frame)
				local particleSize = math.random(1,5)
				particle.Size = UDim2.new(0,particleSize,0,particleSize)
				particle.BackgroundColor3 = color
				particle.BorderSizePixel = 0
				particle.BackgroundTransparency = math.random(0,100) / 100
				particle.ZIndex = 5
				particle.Position = basicMissile.frame.Position + UDim2.new(0, math.random(0,10), 0, math.random(0,10))
				particle:TweenPosition(particle.Position + UDim2.new(0, math.random(-20,20), 0, math.random(-20,20)), &quot;Out&quot;, &quot;Linear&quot;, 2, true)
				coroutine.wrap(function() while particle.BackgroundTransparency &lt; 1 do wait() particle.BackgroundTransparency = particle.BackgroundTransparency + 0.02 end end)()
				game:GetService(&quot;Debris&quot;):AddItem(particle, 6)	
			end
		end)()
		coroutine.wrap(function() wait(timeToTake) basicMissile.frame:Destroy() basicMissile.level.entities[basicMissile.levelId] = nil basicMissile = nil end)()
		return basicMissile
	end
	
	function BasicMissile:render()
	
	end
end
</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="Script" referent="RBX0">
        <Properties>
          <string name="Name">Game.lua</string>
          <ProtectedString name="Source">--The game class coordinates all of the games calls and functions


--Allows access to the datamodel
if script.Parent.ClassName == &quot;LocalScript&quot; then game.Players.LocalPlayer.PlayerGui.Everest2D.Parent = nil end

_G.rbxGame = game
repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

--Defines the game class
do Game = Class(&quot;Game&quot;)

	function Game.new()
		local game = {}
		setmetatable(game, Game)

		Import(&quot;Screen&quot;)
		
		if not _G.isServer then 
			local tempScreenSize = LocalPlayer.PlayerGui.ScreenGui.AbsoluteSize
		
			LocalPlayer.PlayerGui.ScreenGui:Destroy()
			
			game.canvasPart = Instance.new(&quot;Part&quot;, Workspace.CurrentCamera)
			game.canvasPart.Anchored = true
			game.canvasPart.FormFactor = &quot;Custom&quot;
			game.canvasPart.Size = Vector3.new(3*math.tan(math.rad(35)) * 2 * (tempScreenSize.X/tempScreenSize.Y) , 3*math.tan(math.rad(35)) * 2, 0)
			
			Workspace.CurrentCamera.CameraType = &quot;Scriptable&quot;
			Workspace.CurrentCamera.CameraSubject = game.canvasPart
			Workspace.CurrentCamera.CoordinateFrame = CFrame.new(game.canvasPart.Position + game.canvasPart.CFrame.lookVector*3.1, game.canvasPart.Position)
			Workspace.CurrentCamera.Focus = game.canvasPart.CFrame
			
			game.canvas = Instance.new(&quot;SurfaceGui&quot;, game.canvasPart)
			game.canvas.CanvasSize = tempScreenSize
			game.canvas.Adornee = game.canvasPart
			
			Import(&quot;InputHandler&quot;)
			Import(&quot;ClientPacketHandler&quot;)
			
			game.localPlayer = LocalPlayer
			game.inputHandler = InputHandler.new(game)
			game.packetHandler = ClientPacketHandler.new()
			
		else
			game.localPlayer = {Name = &quot;Server&quot;}
			game.canvas = Instance.new(&quot;ScreenGui&quot;, game.ServerStorage)
			
		end
		game.canvas.Name = &quot;Everest2DGame&quot;

		game.screen = Screen.new(game, math.ceil(game.canvas.AbsoluteSize.X / 32), math.ceil(game.canvas.AbsoluteSize.Y / 32))
		game.running = false

		game.tickCount = 0
		game.frameCount = 0

		return game
	end

	function Game:start()
		self.running = true

		Import(&quot;CLIENT_PACKET001_LOGIN&quot;)

		if not _G.isServer then
			self.packetHandler:sendPacket(CLIENT_PACKET001_LOGIN.new():Data())
		end

		coroutine.wrap(function()
			self:run()
		end)()
	end

	function Game:stop()
		self.running = false
		self.player:Destroy()
		self.screen.frame:Destroy()
		self.screen.ClippingMask:Destroy()
		local loaderInfo = Instance.new(&quot;TextLabel&quot;, self.canvas)
		loaderInfo.Size = UDim2.new(1,0,1,0)
		loaderInfo.BackgroundColor3 = Color3.new(0,0,0)
		loaderInfo.Text = &quot;You have lost connection&quot;
		loaderInfo.TextScaled = true
		loaderInfo.TextColor3 = Color3.new(0,0,0)
		loaderInfo.TextStrokeColor3 = Color3.new(141 / 255, 70 / 255, 212 / 255)
		loaderInfo.TextStrokeTransparency = 0
	end

	function Game:run()
		local timeAtStart = tick()
		local lastTime = tick()
		local minTimePerTick = 1/60
		local minTimePerFrame = 1/60

		local ticks = 0
		local frames = 0

		local lastTimer = tick()
		local unProcessedTime = 0
		local unRenderedTime = 0
		local lasttick = tick()
		--The game cycle (calls everything)
		
		_G.rbxGame:GetService(&quot;RunService&quot;).RenderStepped:connect(function()
		--while (self.running) do
			--[[local now = tick()
			unProcessedTime = unProcessedTime + ((now - lastTime) / minTimePerTick)
			unRenderedTime = unRenderedTime + ((now - lastTime) / minTimePerFrame)
			lastTime = now

			while (unProcessedTime &gt;= 1) do
				ticks = ticks + 1
				self:tick()
				unProcessedTime = unProcessedTime - 1
			end

			while (unRenderedTime &gt;= 1) do
				frames = frames + 1
				self:render()
				unRenderedTime = unRenderedTime - 1
			end

			wait(0)

			if (now - lastTimer &gt;= 1 ) then
				lastTimer = lastTimer + 1
				frames = 0
				ticks = 0
			end]]--
			
			self.deltaTime = tick() - lasttick
			self:tick(self.deltaTime)
			self:render(self.deltaTime)
			lasttick = tick()
		end)
	end

	function Game:tick(deltaTime)
		self.tickCount = self.tickCount + 1

		if self.player then
			self.player.level:tick(deltaTime)
		end

	end
	
	function Game:render(deltaTime)
		if not _G.isServer then
			self.frameCount = self.frameCount + 1

			if self.player then
				self.player.level:render(deltaTime)
				self.screen:render(deltaTime, self.player.posX - (self.screen.sizeX / 2), self.player.posY - (self.screen.sizeY / 2))
			end
		end
	end

end

Import(&quot;Server&quot;)

do --MAIN
	wait(2)
	if script.Parent.Parent.Name == &quot;Everest2DServer&quot; then
		Server.new()
		_G.isServer = true
		
		--Tell people that everest is loading when they join
		local loaderScreen = Instance.new(&quot;ScreenGui&quot;, game.StarterGui)
		local loaderInfo = Instance.new(&quot;TextLabel&quot;, loaderScreen)
		loaderInfo.Size = UDim2.new(1,0,1,0)
		loaderInfo.BackgroundColor3 = Color3.new(0,0,0)
		loaderInfo.Text = &quot;Please wait - Everest2D is loading&quot;
		loaderInfo.TextScaled = true
		loaderInfo.TextColor3 = Color3.new(0,0,0)
		loaderInfo.TextStrokeColor3 = Color3.new(141 / 255, 70 / 255, 212 / 255)
		loaderInfo.TextStrokeTransparency = 0
		--Stops people falling when they join
		local loaderBlock = Instance.new(&quot;Part&quot;, Workspace)
		loaderBlock.Anchored = true
		loaderBlock.Size = Vector3.new(100,10,100)
		loaderBlock.Position = Vector3.new(-50, -20, -50)
		wait(5)
	else
		Import(&quot;LocalPlayer&quot;)
		repeat wait() until game.Players.LocalPlayer.Character
		game.Players.LocalPlayer.Character:Destroy()
		game.StarterGui:SetCoreGuiEnabled(2, false)
		wait(5)
	end
	--waits for the server to start up (it creates the packethandler)
	repeat wait() until Workspace:FindFirstChild(&quot;PacketHandler&quot;)
	local game = Game.new()
	_G.localgame = game
	game:start()
end</ProtectedString>
          <Content name="LinkedSource">null</Content>
          <bool name="Disabled">false</bool>
        </Properties>
      </Item>
      <Item class="StringValue" referent="RBX0">
        <Properties>
          <string name="Name">level</string>
          <string name="Value"></string>
        </Properties>
        <Item class="Script" referent="RBX0">
          <Properties>
            <string name="Name">TestLevel.lua</string>
            <ProtectedString name="Source">--A test map

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Level&quot;)
wait(1) --Wait for level to fully declare itself

local levelData = {}

--Example data structure

levelData[1]  = {4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4}
levelData[2]  = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[3]  = {4,1,1,1,1,1,1,1,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[4]  = {4,1,1,1,1,1,1,3,3,2,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[5]  = {4,1,1,1,1,1,3,3,2,5,2,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[6]  = {4,1,1,1,1,3,3,2,5,5,5,2,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[7]  = {4,1,1,1,1,3,2,5,5,5,5,5,2,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[8]  = {4,1,1,1,1,3,3,2,5,5,5,2,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[9]  = {4,1,1,1,1,1,3,3,2,5,2,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[10] = {4,1,1,1,1,1,1,3,3,2,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[11] = {4,1,1,1,1,1,1,1,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[12] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[13] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[14] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[15] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[16] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[17] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[18] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[19] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[20] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[21] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[22] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[23] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[24] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[25] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[26] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[27] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[28] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[29] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[30] = {4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4}
levelData[31] = {4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4}
levelData[32] = {4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4}


Level.TestLevel = Level.new(500,500, nil, &quot;TestLevel&quot;):testRandomGenerate()

Level.ready = true</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
        <Item class="StringValue" referent="RBX0">
          <Properties>
            <string name="Name">tiles</string>
            <string name="Value"></string>
          </Properties>
          <Item class="Script" referent="RBX0">
            <Properties>
              <string name="Name">AnimatedTile.lua</string>
              <ProtectedString name="Source">--Standard tile but with an animated texture

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Extends&quot;)
Import(&quot;BasicTile&quot;)


do AnimatedTile = Extends(&quot;AnimatedTile&quot;, BasicTile)

	--frames = total number of frames
	--delay = time between the frames
	function AnimatedTile.new(id, isWalkable, spriteSheet, spritePosX, spritePosY, frames, delay)
		local animatedTile = BasicTile.new(id, isWalkable, spriteSheet, spritePosX, spritePosY)
		setmetatable(animatedTile, AnimatedTile)
		
		animatedTile.frames = frames
		animatedTile.delay = delay
	
		return animatedTile
	end
	
	function AnimatedTile:render(screen, posX, posY)
	
		local rendered = Instance.new(&quot;ImageLabel&quot;, screen.frame)
		rendered.BorderSizePixel = 0
		rendered.ZIndex = 2
		rendered.Size = UDim2.new(0, 32, 0, 32)
		rendered.Position = UDim2.new(0, posX * 32, 0, posY * 32)
		rendered.Image = self.spriteSheet.url
		rendered.ImageRectSize = self.spriteSheet.vector2Size
		
		local currentFrame = math.floor((screen.game.tickCount / self.delay)) % self.frames
		local frameDir = 1
		local lastFrameTick = screen.game.tickCount
		
		--The loops which animates the tile
		coroutine.wrap(function()
		
			while wait() do
				--Synced with games tickcount for synced animation with other tiles
				currentFrame = math.floor(math.abs(math.sin(screen.game.tickCount / self.delay) * self.frames))
				
				lastFrameTick = screen.game.tickCount + self.delay
				
				--Gets the frames to the right of the spritePosX and spritePosY on the sprite required for the animation
				rendered.ImageRectOffset = Vector2.new(self.spritePosVec.X + (currentFrame * self.spriteSheet.vector2Size.X), self.spritePosVec.Y)
			end
			
		end)()
		
		return rendered
	end
	
	
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="Script" referent="RBX0">
            <Properties>
              <string name="Name">Tile.lua</string>
              <ProtectedString name="Source">--Base tile, extend to make new tile types

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do Tile = Class(&quot;Tile&quot;)
	
	Tile.Tiles = {}
	
	function Tile.new(id, isWalkable)
		local tile = {}
		setmetatable(tile, Tile)		
		
		if Tile.Tiles[id] then error(&quot;Tile ID Conflict id: &quot; .. id) end
		Tile.Tiles[id] = tile
		
		tile.id = id
		tile.isWalkable = isWalkable
				
		return tile
	end
	
	function Tile:tick()
	
	end
	
	function Tile:render(screen, posX, posY)
		
		local rendered = Instance.new(&quot;ImageLabel&quot;, screen.frame)
		rendered.BorderSizePixel = 0
		rendered.ZIndex = 2
		rendered.Size = UDim2.new(0, 32, 0, 32)
		rendered.Position = UDim2.new(0, posX * 32, 0, posY * 32)
		rendered.Image = self.spriteSheet.url
		rendered.ImageRectSize = self.spriteSheet.vector2Size + Vector2.new(-2, -2)
		rendered.ImageRectOffset = self.spritePosVec + Vector2.new(1,1)
		
		
		return rendered
	end
	
	Import(&quot;BasicTile&quot;)
	Import(&quot;AnimatedTile&quot;)
	Import(&quot;SpriteSheet&quot;)
	
	--All tile types are declared here
	--id, walkable, spritesheet, spritesheetposition
	Tile.GRASS = BasicTile.new(1, true, SpriteSheet.BasicSpriteSheet, 0, 0)
	Tile.FLOWER1 = BasicTile.new(2, true, SpriteSheet.BasicSpriteSheet, 32, 0)
	Tile.FLOWER2 = BasicTile.new(3, true, SpriteSheet.BasicSpriteSheet, 64, 0)
	Tile.STONE = BasicTile.new(4, false, SpriteSheet.BasicSpriteSheet, 0, 32)
	Tile.Water = AnimatedTile.new(5, false, SpriteSheet.BasicSpriteSheet, 0, 64, 3, 60)
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
          <Item class="Script" referent="RBX0">
            <Properties>
              <string name="Name">BasicTile.lua</string>
              <ProtectedString name="Source">--Basic general purpose tile

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Extends&quot;)
Import(&quot;Tile&quot;)

do BasicTile = Extends(&quot;BasicTile&quot;, Tile)
	
	function BasicTile.new(id, isWalkable, spriteSheet, spritePosX, spritePosY)
		basicTile = Tile.new(id, isWalkable)
		setmetatable(basicTile, BasicTile)
		
		basicTile.spriteSheet = spriteSheet
		basicTile.spritePosX = spritePosX
		basicTile.spritePosY = spritePosY
		basicTile.spriteSizeX = spriteSheet.spriteSizeX
		basicTile.spriteSizeY = spriteSheet.spriteSizeY	
		basicTile.spritePosVec = Vector2.new(spritePosX, spritePosY)
		
		return basicTile	
	end	
	
end</ProtectedString>
              <Content name="LinkedSource">null</Content>
              <bool name="Disabled">false</bool>
            </Properties>
          </Item>
        </Item>
        <Item class="Script" referent="RBX0">
          <Properties>
            <string name="Name">Level.lua</string>
            <ProtectedString name="Source">--Used to create the maps, extend this to make new ones

repeat wait() until _G.Import
_G.Import(&quot;Import&quot;)

Import(&quot;Class&quot;)

do Level = Class(&quot;Level&quot;)
	
	Level.allLevels = {}
	
	function Level.new(width, height, tiles, name)
		local level = {}
		setmetatable(level, Level)
		
		level.width = width
		level.height = height
		level.tiles = tiles or {}
		level.entities = {}
		level.name = name
		
		Level.allLevels[name] = level
		
		if not tiles then
			for x = 0, level.width do
				level.tiles[x] = {}
			end	
		end	
		
		return level
	end
	
	function Level:tick()
		for _, entity in pairs(self.entities) do
			entity:tick()
		end
		
	end	
	
	function Level:render(deltaTime)
		for _, entity in pairs(self.entities) do
			entity:render(deltaTime)
		end
	end
	
	function Level:getEntityFromId(id)
		return self.entities[id]
	end
	
	Import(&quot;Tile&quot;)
	
	function Level:rayCast(pos, dirVec)
		for i = 1, 30 do
			local id = self.tiles[math.floor(pos.X + dirVec.X * i)] and self.tiles[math.floor(pos.X + dirVec.X * i)][math.floor(pos.Y + dirVec.Y * i)]
			if id then
				local tile = Tile.Tiles[id]
				if not tile.isWalkable then 
					return Vector2.new(pos.X + math.floor(dirVec.X * i), pos.Y + math.floor(dirVec.Y * i)) + Vector2.new(0.5,0.5) - dirVec
				end
			end
		end
		return pos + dirVec * 30
	end
	
	function Level:testRandomGenerate()
		
		repeat wait() until Tile.GRASS
		
		for x = 1, self.width do
			if x%100 == 0 then wait() print(x) end
			for y = 1, self.height do
				local rand = math.random(1, 30)
				if rand == 10  and y &gt; 2 then
					self.tiles[x][y] = Tile.FLOWER1.id
				elseif rand == 20 and y &gt; 2 then
					self.tiles[x][y] = Tile.FLOWER2.id
				elseif rand == 28 and y &gt; 2 then
					self.tiles[x][y] = Tile.GRASS.id
				else
					self.tiles[x][y] = Tile.GRASS.id
				end
			end
		end	
		
		self.ready = true
		return self
	end		
		
end

</ProtectedString>
            <Content name="LinkedSource">null</Content>
            <bool name="Disabled">false</bool>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>
